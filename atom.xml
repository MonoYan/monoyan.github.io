<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanCC&#39;s Blog</title>
  
  
  <link href="http://yancc.cc/atom.xml" rel="self"/>
  
  <link href="http://yancc.cc/"/>
  <updated>2021-01-15T12:56:54.865Z</updated>
  <id>http://yancc.cc/</id>
  
  <author>
    <name>Wang Yan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>愤怒的小鸟游戏实现</title>
    <link href="http://yancc.cc/2021/01/15/angrybirds/"/>
    <id>http://yancc.cc/2021/01/15/angrybirds/</id>
    <published>2021-01-15T11:42:28.000Z</published>
    <updated>2021-01-15T12:56:54.865Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个愤怒的小鸟的游戏实现记录</p><a id="more"></a><h1 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h1><ol><li>小鸟的拖拽（最大距离限制）</li><li>小鸟的飞出</li><li>小鸟与猪、障碍物碰撞（死亡、受伤）</li><li>皮筋的绘制</li><li>一只小鸟的影分身</li><li>effects</li><li>镜头跟随</li><li>游戏结束以及胜利的判定</li><li>添加音效</li></ol><h1 id="UI制作"><a href="#UI制作" class="headerlink" title="UI制作"></a>UI制作</h1><ol><li>关卡选择</li><li>数据存储</li></ol><h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><ul><li>Sprite Renderer组件中SortingLayer设置图层，Order In Layer实现层级</li></ul><h2 id="实现拖拽效果"><a href="#实现拖拽效果" class="headerlink" title="实现拖拽效果"></a>实现拖拽效果</h2><p>使用SpringJoint2D来设置弹力，关闭Auto Configure Distance手动设定一个距离</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一个愤怒的小鸟的游戏实现记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="http://yancc.cc/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>UGUI 学习笔记</title>
    <link href="http://yancc.cc/2021/01/04/UGUI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yancc.cc/2021/01/04/UGUI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-04T00:55:15.000Z</published>
    <updated>2021-01-16T06:59:34.624Z</updated>
    
    <content type="html"><![CDATA[<p>UGUI 相关学习记录（最后更新：1.15），目前：画布；Rect Transform 组件；Event System组件；Image；Sprite Editor；Sprite Packer；Sprite Atlas；Raw Image；Text；Mask；特效；UI元素的渲染与性能</p><a id="more"></a><h1 id="一、画布"><a href="#一、画布" class="headerlink" title="一、画布"></a>一、画布</h1><h2 id="UI元素的渲染顺序"><a href="#UI元素的渲染顺序" class="headerlink" title="UI元素的渲染顺序"></a>UI元素的渲染顺序</h2><ul><li>根据hierarchy依次渲染</li></ul><h3 id="用代码更改渲染方式"><a href="#用代码更改渲染方式" class="headerlink" title="用代码更改渲染方式"></a>用代码更改渲染方式</h3><p>Transform/RectTransform的SetAsFirstSibling() / SetAsLastSibling() / SetSibingIndex()的方法实现</p><h2 id="画布渲染模式与属性"><a href="#画布渲染模式与属性" class="headerlink" title="画布渲染模式与属性"></a>画布渲染模式与属性</h2><h3 id="Screen-Space-Overlay"><a href="#Screen-Space-Overlay" class="headerlink" title="Screen Space - Overlay"></a>Screen Space - Overlay</h3><p>画布无论在场景何处都会渲染覆盖整个画面，会随着游戏视图大小而改变</p><ul><li><p>Pixel Perfect</p><p>UI内像素渲染统一</p></li><li><p>Sort Order</p><p>通过数值设置画布上的渲染顺序，越小内侧优先，越大外侧优先</p></li></ul><h3 id="Screen-Space-Camera"><a href="#Screen-Space-Camera" class="headerlink" title="Screen Space-Camera"></a>Screen Space-Camera</h3><p>画布通过指定的摄像机进行渲染</p><p>摄像机会影响到UI元素的呈现效果，如果摄像机的Projection的属性被设置为Perspective的话，UI就会略带透明效果（透明度跟着摄像机的Field of view）的属性变化</p><p>画布会自适应对着摄像机的视口调整大小、位置、朝向、以正面面对摄像机</p><ul><li><p>Pixel Perfect</p><p>UI内像素渲染统一</p></li><li><p>Rander Camera</p><p>指定渲染的摄像机</p></li><li><p>Plane Distance</p><p>设置从画布到摄像机的距离</p></li><li><p>Sorting Layer</p><p>控制渲染顺序但与distance(Z)无关</p></li><li><p>Order in Layer</p><p>通过数值设置画布上的渲染顺序，越小内侧优先，越大外侧优先</p></li></ul><h3 id="World-Space"><a href="#World-Space" class="headerlink" title="World Space"></a>World Space</h3><p>与场景内其他游戏对象一样处理，画布由Rect Transform组件来定义</p><p>按照3D空间上的位置关系进行渲染</p><p>适用于将UI元素作为场景的一部分来处理的情况</p><ul><li><p>Event Camera</p><p>指定处理事件的摄像机</p></li><li><p>Sorting Layer 、Order in Layer</p><p>同上</p></li></ul><h2 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h2><h4 id="Ui-Scale-Mode"><a href="#Ui-Scale-Mode" class="headerlink" title="Ui Scale Mode"></a>Ui Scale Mode</h4><ul><li><p>Constant Pixel Size 根据画布的UI元素比例和像素密度来设置，会影响画布内的所有元素</p><ul><li><p>Scale Factor </p><p>UI缩放的系数</p></li><li><p>Refence Pixels Per Unit</p><p>标准单位的像素数</p></li></ul></li><li><p>Scale With Screen Size 根据分辨率来创建UI</p><ul><li><p>Reference Resolution</p><p> 设置缩创建UI的标准分辨率</p></li><li><p>Screen Match Mode</p><p>设置画布宽高比不同时的缩放</p></li><li><p>Match Width Or Height | Match值为（0.0-1.0）</p><p>结合分辨率的宽高缩放画布</p></li><li><p>Expand</p><p>扩展画布，但分辨率不降低</p></li><li><p>Shrink</p><p>收缩画布的区域、画布的宽高同时收缩，均不超过参照分辨率</p></li><li><p>Reference Pixels Per Unit</p><p>设置画布上，每个单位的标准像素数</p></li></ul></li><li><p>World 当画布渲染模式为World Space时，Ui Scale Mode属性的固定值</p><ul><li><p>Dynamic Pixels Per Unit</p><p>与文本一样，设置UI上动态生成图形的每单位像素数</p></li><li><p>Reference Pixels Per Unit</p><p>设置画布上，每个单位的标准像素数</p></li></ul></li></ul><h2 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h2><p>EventSystem的核心是Raycasting机制</p><p>本质是从某个坐标到其他坐标渲染的一条假象的直线，称为Ray，起作用是检测与场景上对象之间冲突的机制</p><p>通过Graphic Raycaster可以判断用户操作的UI元素是画布上的哪个UI元素</p><h3 id="Ignore-Reversed-Graphics"><a href="#Ignore-Reversed-Graphics" class="headerlink" title="Ignore Reversed Graphics"></a>Ignore Reversed Graphics</h3><p>忽略反转并显示了背面的图形</p><h3 id="Blocking-Objects"><a href="#Blocking-Objects" class="headerlink" title="Blocking Objects"></a>Blocking Objects</h3><p>指定阻挡光线投射的对象</p><ul><li>None</li><li>2D</li><li>3D</li><li>ALL</li></ul><h3 id="Blocking-Mask"><a href="#Blocking-Mask" class="headerlink" title="Blocking Mask"></a>Blocking Mask</h3><p>指定阻挡光线投射的对象的层</p><h2 id="Canvas-Renderer"><a href="#Canvas-Renderer" class="headerlink" title="Canvas Renderer"></a>Canvas Renderer</h2><p>画布中所有图形元素都附加了~组件，作用是元素渲染到画布 </p><h2 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h2><p>通过画布组将多个UI元素分组，统一设定或修改某个属性</p><ul><li><p>Alpha</p><p>设置不透明度(0~1.0)</p><p>如果UI元素一又Alpha值，就会使用相乘后所得的值</p></li><li><p>Interactable</p><p>设置画布组内的UI元素是有效还是无效状态</p></li><li><p>Blocks Raycasts</p><p>设置画布组内的所有UI元素是否阻挡管线投射（判断碰撞）</p><p>多适用于HUD上的状态显示或指示器</p></li><li><p>Ignore Parent Groups</p><p>画布被嵌套时，忽略在父级画布组的属性</p></li></ul><h1 id="二、Rect-Transform-组件"><a href="#二、Rect-Transform-组件" class="headerlink" title="二、Rect Transform 组件"></a>二、Rect Transform 组件</h1><p>Canvas上附加的为Rect Transform组件</p><h2 id="Rect工具"><a href="#Rect工具" class="headerlink" title="Rect工具"></a>Rect工具</h2><h3 id="枢轴（Pivot）"><a href="#枢轴（Pivot）" class="headerlink" title="枢轴（Pivot）"></a>枢轴（Pivot）</h3><p>已选矩形的中央位置，显示蓝色标志的就是Pivot</p><p>Pivot是所选UI元素调整或旋转的基准点，Rect Transform组件中的Pos X和Pox Y显示数周位置的坐标</p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>按住shift可以只横纵移动</p><h3 id="调整尺寸-Resize和scale的区别"><a href="#调整尺寸-Resize和scale的区别" class="headerlink" title="调整尺寸 - Resize和scale的区别"></a>调整尺寸 - Resize和scale的区别</h3><ul><li>Resize <ul><li>虽然能改变UI元素的宽度和高度，但是Scale属性的值不变，不影响UI元素内设置了字体大小于slice的sprite边界部分的宽度</li><li></li></ul></li><li>Scale<ul><li>比起改变UI元素的尺寸，更要的是扩大、缩小的功能，所以会改变UI元素内的字体与边界的外观尺寸</li><li>可以把值设为1.0就可以恢复原有尺寸，相比Resize还需要记住原本尺寸更有效</li></ul></li></ul><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>按住shift拖拽旋转，以按住shift的角度每15°旋转一下</p><h3 id="Transform-Gizmo-Toggles"><a href="#Transform-Gizmo-Toggles" class="headerlink" title="Transform Gizmo Toggles"></a>Transform Gizmo Toggles</h3><ul><li>Center 和 Pivot 模式<ul><li>center下不可以移动枢轴，pivot可以</li></ul></li><li>Global 和 Local 模式<ul><li>在local模式下，旋转UI元素，所选矩形也随之旋转，保持旋转方向时，使UI元素发生变形</li></ul></li></ul><h2 id="Rect-Transform组件属性"><a href="#Rect-Transform组件属性" class="headerlink" title="Rect Transform组件属性"></a>Rect Transform组件属性</h2><ul><li><p>Pos X Pos Y</p><p>设置UI元素的位置。以象具锚点的相对坐标表示枢轴的坐标位置</p></li><li><p>Width Height</p><p>设置UI元素的宽度和高度</p></li><li><p>Left Top Right Bottom</p><p>分别设置从父元素的左上右下到UI元素的左上右下的距离</p><p>打开锚点控制柄时，可以分别代替Pos X、Pos Y、Width、Height</p></li><li><p>Pos Z</p><p>设置UI元素的Z坐标</p></li><li><p>Anchors</p><p>设置锚点位置</p></li><li><p>Pivot</p><p>设置枢轴的位置</p><p>X，Y的有效范围0.0~1.0，这是对于Rect Transform的宽度与高度的相对位置</p><p>e.g. X=0.0、Y=0.0的话就显示Rect Transform的左下方，如果1.0就显示在右上方</p></li><li><p>Scale</p><p>UI元素的缩放</p></li></ul><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>将Rect Transform的控制柄与父UI元素的某个特定位置链接的功能</p><p>通过锚点就可以让UI适应各种设备的屏幕分辨率</p><h3 id="移动-1"><a href="#移动-1" class="headerlink" title="移动"></a>移动</h3><p>按住shift拖拽锚点时候，Rect Transform控制柄也保持对锚点控制柄相同距离移动</p><h3 id="用锚点布局"><a href="#用锚点布局" class="headerlink" title="用锚点布局"></a>用锚点布局</h3><p>锚点控制柄表示在父元素领域内的相对位置，因此会随着父元素的大小调整而移动</p><p>4个锚点控制柄分别对应了Rect Transform四个角上控制柄，移动时会保持锚点控制柄与Rect Transform控制柄之间的距离。</p><ul><li><p>如果UI元素的大小调整好就把锚点固定父级元素上，父级元素缩放被打了锚点的UI元素就会被拖拽着同比例缩放</p></li><li><p>将4个锚点都设置为父元素的右下角，UI元素与父元素右侧和下方边的边距就固定了。可以将UI元素放在父元素右下角为基准位置</p></li><li><p>如果锚点控制位左右各两个，分别在父元素左端和右端，结合父元素的宽度，UI元素的宽度也随之变化，由于锚点设置为父元素的上下的中央位置，所以UI元素的高度不会发生变化</p></li><li><p>如果锚点设置为Rect Transform相同位置的时候，控制柄的对父元素的大小比例就固定了，随着父元素的变化，UI元素大小也会发生变化</p></li></ul><h3 id="预制的锚点"><a href="#预制的锚点" class="headerlink" title="预制的锚点"></a>预制的锚点</h3><p>在Anchor Presets中，按住shift选择就可以在设置锚点的同时移动枢轴，如果按住alt的同时就i可以设置UI元素的位置和大小</p><h3 id="Inspector中的Anchors面板"><a href="#Inspector中的Anchors面板" class="headerlink" title="Inspector中的Anchors面板"></a>Inspector中的Anchors面板</h3><p>Min表示的是左下角的锚点位置，Max表示的是右上角的锚点位置</p><p>锚点控制关闭时：PosX和PosY显示锚点距离枢纽的相对位置，Width和Height表示的是UI元素的宽和高</p><p>锚点控制开启时：会变为Left 、Right  、Top 、 Bottom</p><h2 id="Blueprint模式与Raw-edit模式"><a href="#Blueprint模式与Raw-edit模式" class="headerlink" title="Blueprint模式与Raw edit模式"></a>Blueprint模式与Raw edit模式</h2><p>Blueprint：</p><ul><li>开启后可以利用未经旋转或缩放的状态来调整UI大小</li></ul><p>Raw edit：</p><ul><li>更改锚点属性的值时候，会同时保持锚点与控制手柄同时执行动作，会改变UI元素的大小</li><li>如果更改Pivot属性的值，UI元素上的枢纽位置也会变化，但因为在保持枢轴坐标的基础上执行的动作 ，所以UI元素的外观位置不会改变</li></ul><h2 id="游戏对象与Rect-Transform"><a href="#游戏对象与Rect-Transform" class="headerlink" title="游戏对象与Rect Transform"></a>游戏对象与Rect Transform</h2><p>Shift+Ctrl+N创建的Empty Object不是画布的子元素，也不会自动附加Rect Transform</p><p>Alt+Shift+N创建的游戏对象（菜单中为Create Empty Child）会自动附加</p><h1 id="三、Event-System（运行机制）"><a href="#三、Event-System（运行机制）" class="headerlink" title="三、Event System（运行机制）"></a>三、Event System（运行机制）</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ul><li>事件系统通过场景中EventSystem对象所附加的”Event System”, “Standalone Input Module”, “Touch Input Module”组件发挥功能</li><li>EventSystem通常会随着Canvas创建而创建，一个场景中唯一</li><li>基本作用<ul><li>管理已选游戏对象</li><li>管理活动的输入模块</li><li>管理所有的输入模块</li><li>通过光线投射判断对象</li></ul></li></ul><p>*EventSystem以及输入模块的累实在UnityEngine.EventSystem命名空间中定义的</p><h2 id="Event-System组件的动作"><a href="#Event-System组件的动作" class="headerlink" title="Event System组件的动作"></a>Event System组件的动作</h2><p>Event System与各个输入模块联合执行动作，向State或特定覆盖的组件传递信息</p><p>执行流程</p><ol><li>动作开始时找出游戏对象附加的输入模块，添加到内部列表</li><li>每当调用Update方法，所附加的各个输入模块的UpdateModule就会被调用，各个输入模块，通过UpdateModule方法可以改变内部状态</li><li>调用所有输入模块的UpdateModule方法后，调用活动的输入模块的Process方法，实现独立处理写在此</li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>First Selected</li><li>Send Navigation Events （发送当前输入器发生的导航事件 OnMove、OnSubmit、OnCancel事件）</li><li>Drag Threshold（以像素单位来设置判定拖拽已经开始的移动距离）</li></ul><h2 id="Input-Module"><a href="#Input-Module" class="headerlink" title="Input Module"></a>Input Module</h2><p>让事件系统执行什么动作的组件，被用于接受输入，管理事件状态，向场景中的东西发送事件等</p><p>由于Event System组件时对于输入模块采取处理，所以输入模块也要附加在游戏对象</p><p>输入模块每次只会有一个处于活动状态，活动的输入模块是根据操作环境来决定的</p><p>Event System对象一般会有Standalone Input Module和Touch Input Module组件</p><h3 id="Standalone-Input-Module组件"><a href="#Standalone-Input-Module组件" class="headerlink" title="Standalone Input Module组件"></a>Standalone Input Module组件</h3><p>用于追踪鼠标光标正指向哪里，检测鼠标、键盘、手柄的哪个按键或键被按下</p><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><ul><li><p>Horizontal Axis</p><p>指定横轴按钮对应的Input Manager的设置</p><p>Project Settings中的input可以定义项目中所有输入以及输入相对应的游戏中的动作</p></li><li><p>Vertical Axis</p><p>指定纵轴按钮对应的Input Manager的设置</p></li><li><p>Submit Button</p></li><li><p>Cancel Button</p></li><li><p>Input Actions Per Second</p><p>设置每秒可以接受多少次键盘或手柄的输入动作</p></li><li><p>Repeat Delay</p><p>设置连续输入起止之间延迟的事件，避免无意识的输入</p></li><li><p>Allow Activation On Mobile Device</p></li></ul><h3 id="Touch-Input-Module组件"><a href="#Touch-Input-Module组件" class="headerlink" title="Touch Input Module组件"></a>Touch Input Module组件</h3><p>负责在手机、Pad、电脑等设备的输入</p><h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><ul><li>Allow Activation On Standalone</li></ul><h2 id="光线投射"><a href="#光线投射" class="headerlink" title="光线投射"></a>光线投射</h2><p>输入模块通过Raycaster组件检测应该为场景内哪个对象发送输入事件，光想投射根据指定的屏幕坐标对场景内的对象进行光线投射，返回最进阶画面的对象</p><p>在Unity中标准的Raycaster有以下组件</p><ul><li>针对图像元素的Graphic Raycaster</li><li>针对3D对象的Physics Raycaster<ul><li>需要设置为目标的3D对象Collider</li><li>通过Event Mask属性可以设置作为光线投射对象的3D对象的层</li><li>需要Camera组件，如果没有Camera组件，会自动附加</li></ul></li><li>针对2D对象的Physics Raycaster<ul><li>需要设置为目标的2D对象Collider</li><li>通过Event Mask属性可以设置作为光线投射对象的2D对象的层</li><li>需要Camera组件，如果没有Camera组件，会自动附加</li></ul></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>每单位的移动和缩放如果想要标准化数值时可以按住Ctrl或者Command来移动和缩放，移动会以每一个单位捕捉，缩放为0.1个单位</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><ul><li><p>世界坐标系</p><p>场景3D空间中的绝对坐标系，游戏对象的位置并不受层次构造影响，以距离场景坐标点的坐标来表示的</p></li><li><p>屏幕坐标系</p><p>以Game视图的左下角为原点的坐标系，一单位为一像素</p></li><li><p>视口坐标系</p><p>将屏幕坐标系的坐标转换为0.0~1.0的标准坐标系</p></li><li><p>本地坐标系</p><p>以父游戏对象的原地为标准的i昂对坐标系</p><p>画布内的UI元素，将锚点的位置为标准坐标</p><p>Transform和Rect Transform组的Inspector面板上显示的坐标就属于该坐标</p></li></ul><h1 id="四、Image"><a href="#四、Image" class="headerlink" title="四、Image"></a>四、Image</h1><p>UI元素的组件构成由 <code>Visual Component</code> 和 <code>Interaction Component</code> 构成</p><h2 id="与2D-Sprite的不同"><a href="#与2D-Sprite的不同" class="headerlink" title="与2D Sprite的不同"></a>与2D Sprite的不同</h2><ul><li>2D Sprite是通过Sprite Renderer组件在3D空间上渲染的，附加的组件是Transform，通过Scale属性来调整比例改变大小</li><li>image为canvas的子元素由Canvas Renderer组件渲染，附加的组件为Rect Transform，可以通过Width/Height进行像素单位的调整，也可以通过Scale来调整比例的大小</li></ul><h2 id="Image-组件的属性"><a href="#Image-组件的属性" class="headerlink" title="Image 组件的属性"></a>Image 组件的属性</h2><ul><li>Scource Image</li><li>Color</li><li>Material</li><li>Image Type</li></ul><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>Image包括Simple、Sliced、Tiled、Filled四种种类，对应的显示方法也各不相同</p><h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>适应Rect Transform的范围来显示Sprite</p><ul><li><p>Preserve Aspect Ratio</p><p>勾选后Sprite讲无视横纵比例铺满现实在Image的Rect Transform范围内</p><p>为勾选则会保持Sprite原始的横纵比例以最大的尺寸显示在~范围内</p></li><li><p>Set Native Size</p><p>按等倍像素重新调整图像中的精灵大小</p></li></ul><h3 id="Sliced"><a href="#Sliced" class="headerlink" title="Sliced"></a>Sliced</h3><p>Sliced的图像所显示的是切片后的精灵</p><ul><li><p>切片手法</p><p>将一个图像分割成横3x纵3这个9个区域，4角的尺寸保持不变，上边和下边横向拉伸，左边和右边纵向拉伸，即使调整了大小也会显得很美观，适合用做窗口的边框和按钮等的显示</p></li><li><p>Fill Center</p><p>勾选状态后Sprite的中间部分也会被渲染，去掉勾选则不渲染中央部分</p></li></ul><h3 id="Tiled"><a href="#Tiled" class="headerlink" title="Tiled"></a>Tiled</h3><p>Tiled是以Sprite作为一个图样，像瓷砖一样在Rect Transform范围内铺满排列显示，基准点为Rect Transform左下方</p><ul><li><p>如果所显示的Sprite设置了切片时，Sliced设置切片时，将介于Tlied和Sliced之间显示，保持4角尺寸不变，上边下边横向延伸，中央部分将纵横覆盖图样。基准点为中央部分的左下方</p></li><li><p>Fill Center</p><p>同Sliced的Fill Center</p></li></ul><h3 id="Filled"><a href="#Filled" class="headerlink" title="Filled"></a>Filled</h3><p>和Simple图像同样是适应Rect Transform来显示Sprite的，可以通过Fill Method属性和Fill Amount属性对如何涂抹、涂抹多少来显示进行设置</p><ul><li><p>Fill Method</p><p>有以下五种涂抹方式，Fill Amount属性下可以设置0.0 ~ 1.0的涂抹量，Fill Amount属性设1.0时，Filled和Simple图像外观完全相同</p><p>与Simple图像一样，都可以设置Preserve Aspect Ratio属性</p><p>可以通过Set Native Size来重新调整图像中Sprite的大小</p><ul><li><p>Horizontal</p><p>横向涂抹，通过Fill Origin属性可以设置涂抹的基准点</p></li><li><p>Vertical</p><p>纵向涂抹，通过Fill Origin属性可以设置涂抹的基准点</p></li><li><p>Radial 90</p><p>以Rect Transform范围4角的任意一角为基准点进行扇形涂抹，通过Fill Origin属性可以设置涂抹的基准点</p></li><li><p>Radial 180</p><p>以Rect Transform范围4角的任意中点为基准点进行扇形涂抹，通过Fill Origin属性可以设置涂抹的基准点</p><p>可以通过Clockwise设置顺时针逆时针</p></li><li><p>Radial 360</p><p>以Rect Transform范围的中央为基准点进行扇形涂抹，通过Fill Origin属性可以设置涂抹的基准点</p><p>可以通过Clockwise设置顺时针逆时针</p></li></ul></li></ul><h2 id="Sprite-动画"><a href="#Sprite-动画" class="headerlink" title="Sprite 动画 *"></a>Sprite 动画 *</h2><p>将Project面板钟大哥多个Sprite拖放至Hierarchy面板中，就可以逐帧显示2D Sprite的动画</p><p>如果要创建以Image显示的Sprite动画就需要通过手动为各个关键帧设置精灵，但更为方便的还是通过脚本来实现</p><p>*各个Sprite的名字末尾要加上表示顺序的编号</p><p>代码3-1 <a href="https://github.com/wikibook/ugui" target="_blank" rel="noopener">代码</a></p><p>创建的Sprite动画即使替换了图像的Sprite，其尺寸也不会发生变化，因此Sprite动画后的精灵尺寸不想同时，将无法渲染</p><p>为图像附加Content Size Fitter就可以结合Sprite的变更来修改图像的尺寸，将 Horizontal Fit 和 Vertical Fit 设置为Preferred Size</p><h1 id="五、Sprite-Editor"><a href="#五、Sprite-Editor" class="headerlink" title="五、Sprite Editor"></a>五、Sprite Editor</h1><p>在Sprite Editor中设置显示的Sprite，在~中可设置从纹理中所进行的Sprite裁剪和切片</p><p>*纹理的Texture Type必须为Sprite(2D and UI)</p><p>*需要提前在Windwo -> Package Manager 里导入 2D Sprite</p><h2 id="Sprite-Mode"><a href="#Sprite-Mode" class="headerlink" title="Sprite Mode"></a>Sprite Mode</h2><p>将多个图形汇总到一个纹理的称为Texture atlas</p><p>Sprite的纹理需要用到多个图形的时候，从纹理的Import Settings下的Sprite Mode中选择”multiple”</p><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p>当Sprite Mode为Multiple时，在编辑器中选择一个Sprite中，就可以正常调整大小或移动范围</p><p>拖拽绿色的手柄就可以设置Sprite的切片，设置了切片的Sprite就可以运用在Image Type属性为Sliced或Tiled的图像中</p><p>在右下角可以看到编辑中过的Sprite的属性</p><ul><li>Name</li><li>Position</li><li>Border</li><li>Pivot *</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>当Sprite Mode为Multiple时，在编辑中拖拽就可以创建Sprite</p><p>在编辑器上方的Slice中可以设置自动从纹理裁剪出多少个Sprtie</p><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><ul><li><p>Automatic</p><p>基于纹理的阿尔法值，裁剪阿尔法值不为0的范围作为Sprite</p><ul><li>Pivot</li><li>Method<ul><li>Delete Existing</li><li>Smart 保留已有Sprite的Name、Border、Pivot的设置，基于阿尔法的值对范围内进行再设置，创建新的精灵</li><li>Safe 保留包括已有Sprite范围内的所有设置，创建新的</li></ul></li></ul></li></ul><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>是以所设置的宽度喝高度等间隔排列的方格辣裁剪Sprite</p><ul><li>Pixel Size</li><li>Offset 纹理左上方起始的相对坐标来设置方格的开始位置</li><li>Padding 以像素为单位设置方格的间隔</li><li>Pivot</li></ul><h2 id="Sprite-Editor的其他功能"><a href="#Sprite-Editor的其他功能" class="headerlink" title="Sprite Editor的其他功能"></a>Sprite Editor的其他功能</h2><h3 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h3><p>对选中的Sprite不透明部分进行裁剪，可以使用Shift+T</p><h3 id="Revert、Apply"><a href="#Revert、Apply" class="headerlink" title="Revert、Apply"></a>Revert、Apply</h3><h3 id="颜色条按钮"><a href="#颜色条按钮" class="headerlink" title="颜色条按钮"></a>颜色条按钮</h3><p>切换纹理图片的显示和阿尔法水平的显示</p><h3 id="缩放滑块"><a href="#缩放滑块" class="headerlink" title="缩放滑块"></a>缩放滑块</h3><h1 id="六、Sprite-Packer-（legacy-version）"><a href="#六、Sprite-Packer-（legacy-version）" class="headerlink" title="六、Sprite Packer （legacy version）"></a>六、Sprite Packer （legacy version）</h1><p>为了解决单独纹理加载造成的内存浪费，需要将多个纹理汇总到一个纹理图集中，通过Sprite Packer就可以将一个个的纹理生成纹理图集，纹理图集的生成再Play模式和构建模式下是自动进行的</p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>Project Setting -> Editor ->Sprite Packer -> Mode 中开启</p><ul><li>Enabled For Builds</li><li>Always Enabled</li><li>Disable</li></ul><p>设置好模式后，再Project面板选择纹理，设置Import Settings的Packing Tag，设置相同的了相同的Packing Tag纹理会被汇总到同一个纹理图集中</p><p>Sprite Packer所生成的纹理图最大为2048*2048像素，覆盖Import Settings中混合有多种Format时，会分别为各格式生成纹理图集</p><p>虽然集中生成了所有的纹理图集，但实际上只要加载必要的纹理图集。生成的纹理图集缓存于项目的Library/AtlasCache文件夹中</p><h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><p>Windwos菜单中可以打开Sprite Packer的窗口</p><ul><li>Pack \ Repack</li></ul><p>单击Pack会生成纹理图集，已生成的无变动不会更新，Repack在单独的封装视泽中使用</p><ul><li>纹理图集选择下拉菜单</li></ul><p>选择所显示的纹理图集，精灵未能全部归纳到一个纹理图集时，可以进行换页显示</p><ul><li><p>封装规则选择下拉菜单</p><ul><li><p>封装规则</p><p>如何将Sprite放置到纹理图集中</p></li><li><p>DefaultPackerPolicy</p><p>标准的封装规则，设置Tag时，可以在开头加入[TIGHT]，这样就可以只为该Sprite以用TightPackerPolicy，同理还有[RECT]</p></li><li><p>TightPackerPolicy</p><p>基于渲染时实际的多边形罗坤，吧Sprite放在精灵图集中</p></li></ul></li><li><p>颜色条按钮</p></li><li><p>缩放</p></li></ul><h2 id="单独的封装规则"><a href="#单独的封装规则" class="headerlink" title="单独的封装规则"></a>单独的封装规则</h2><p>创建一个实现IPackerPolicy接口类的编辑器脚本来实现单独的封装规则，~需要实现以下两个函数</p><ul><li><p>Public int GetVersion</p><p>返回单独的封装规则的版本号，掌握SP的纹理图集生成逻辑是否发生了变化</p></li><li><p>Public void OnGroupAtlases(BuildTarget target,Packer Job job,int[] texturelmporterinstanceIDs)</p><p>在此函数实现单独的纹理图集生成逻辑</p></li></ul><h1 id="七、Sprite-Atlas"><a href="#七、Sprite-Atlas" class="headerlink" title="七、Sprite Atlas"></a>七、Sprite Atlas</h1><p>Sprite Atlas对于Sprite Packer全面改善，将更多控制权交给了用户</p><p>（以下内容来自官方手册）</p><h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><p>在Project面板create创建</p><h2 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h2><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><h4 id="Variant"><a href="#Variant" class="headerlink" title="Variant"></a>Variant</h4><ul><li><p>Master Atlas</p><p>Variant Atlas会复制Main Altas的副本，当成自己的副本，需要分配一个Main Altas给Variant Atlas，Main Altas本身不能是Viriant Atlas</p></li><li><p>Include in Build</p></li><li><p>Scale</p><p>设置Variant Sprite Atlas的比例因子，范围从0.1-1.0</p><p>Variant Atlas Texture的大小是Master Atlas的Texture乘以<strong>Scale</strong>值的结</p></li><li><p>Include in Build </p><p>将Sprite Atlas Assests 包括在当前版本中</p></li><li><p>Allow Rotation</p><p>以允许将Unity打包到Sprite Atlas中时Sprite旋转，如果Sprite Atlas包含<a href="UICanvas.html">Canvas UI</a>元素Textures，请禁用此选项</p></li><li><p>Tight Packing</p><p>选中此框可根据Sprite轮廓而不是默认的矩形轮廓打包Sprite</p></li><li><p>Padding</p><p>定义多少像素在Sprite Atlas中的各个Sprite纹理之间。这是一个缓冲区，用于防止在Sprite Atlas中彼此相邻的Sprite之间出现像素重叠。默认值为4像素</p></li><li><p>Read/Write Enabled</p><p>选中此框以启用从脚本函数（例如<a href="../ScriptReference/Texture2D.SetPixels.html">Texture2D.SetPixels</a>和其他<a href="../ScriptReference/Texture2D.html">Texture2D</a>函数）对Texture数据的访问。如果启用此属性，则Unity将创建纹理数据的副本。这会使纹理资产所需的内存量增加一倍，并且可能会对性能产生负面影响。默认情况下禁用此属性。该属性仅对未压缩或DXT压缩纹理有效，因为Unity无法读取其他类型的压缩纹理。</p></li><li><p>Gqenerate Mip Maps</p></li><li><p>sRGB</p><p>可将纹理存储在伽玛空间中</p></li><li><p>Filter Mode</p><p>Unity在转换过程中拉伸时如何过滤打包的Textures</p></li><li><p>Default</p><p>为Sprite Atlas的每个目标平台设置分辨率，文件大小以及相关的内存大小要求，像素大小和纹理质量。</p></li><li><p>Objects For Packing</p><p>Unity将此列表中的所有项目打包到当前选定的Sprite Atlas中</p></li></ul><h1 id="八、Raw-Image"><a href="#八、Raw-Image" class="headerlink" title="八、Raw Image"></a>八、Raw Image</h1><p>Raw Image与Image一样适用于显示图形的UI元素</p><ul><li><p>Image用于显示Sprite</p></li><li><p>Raw Image用于显示纹理吗，无法使用切片和平铺等Sprite的特有功能</p></li></ul><p>绝大多数情况下，图像显示使用Image就足够了，但是例如显示照片图像和使用WWW类所下载的纹理就要使用Raw Image了</p><h2 id="组件属性"><a href="#组件属性" class="headerlink" title="组件属性"></a>组件属性</h2><ul><li><p>Texture</p></li><li><p>Color</p></li><li><p>Material</p></li><li><p>UV Rect</p><p>设置原始图像范围内的纹理的偏移值与尺寸，X,Y是以原始图像范围的左下方为原点的坐标，W与H分别相对于原始图像的宽和高，各值范围为0.0~1.0</p><p>e.g. X=0.25，则纹理宽度的仅1/4处偏移至左侧，另外如果设置W=0.5 H=0.5，则纹理会刚考扩大两倍显示</p><p>通过控制UV Rect属性，就可以仅显示大纹理的一部分或缩放显示</p></li><li><p>Set Native Size</p></li></ul><h1 id="九、Text"><a href="#九、Text" class="headerlink" title="九、Text"></a>九、Text</h1><h2 id="组件属性-1"><a href="#组件属性-1" class="headerlink" title="组件属性"></a>组件属性</h2><ul><li><p>Text</p></li><li><p>Font</p></li><li><p>Font Style</p></li><li><p>Font Size</p></li><li><p>Line Spacing</p></li><li><p>Rich Text</p></li><li><p>Alignment</p></li><li><p>Horizontal Overflow</p><ul><li><p>Wrap</p><p>将字符串超出文本范围宽度的部分自动换行显示。但是可能会有出现标点符号等行头禁止字符放置到行头，左括号等行尾今只字符放置到行尾的情况</p></li><li><p>Overflow</p><p>字符不做换行显示</p></li></ul></li><li><p>Vertical Hoverflow</p><p>设置因字符串过长而无法容纳于文本范围的高度时的换行方法</p><ul><li><p>Truncate</p><p>不显示超出范围的字符串</p></li><li><p>Overflow</p><p>仍显示超出范围的字符串</p></li></ul></li><li><p>Best Fit</p><p>自动调整大小以使字符串在文本范围内显示</p><p>勾选后会忽略在Font Size中设定的值，二十介于MinSize中最小和MaxSize中最大值来显示字符串</p></li><li><p>Color</p></li><li><p>Material</p></li></ul><h2 id="Rich-Text"><a href="#Rich-Text" class="headerlink" title="Rich Text"></a>Rich Text</h2><p>勾选了Rich Text后可以使用与HTML相似的语法格式修饰字符串</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag"><<span class="hljs-name">b</span>></span><span class="hljs-tag"></<span class="hljs-name">b</span>></span><span class="hljs-tag"><<span class="hljs-name">i</span>></span><span class="hljs-tag"></<span class="hljs-name">i</span>></span><span class="hljs-tag"><<span class="hljs-name">color=</span> ></span><span class="hljs-tag"></<span class="hljs-name">color</span>></span><span class="hljs-tag"><<span class="hljs-name">size=</span> ></span><span class="hljs-tag"></<span class="hljs-name">size</span>></span>etc.</code></pre></div><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><h3 id="TrueType和OpenType"><a href="#TrueType和OpenType" class="headerlink" title="TrueType和OpenType"></a>TrueType和OpenType</h3><ul><li><p>Font Size</p></li><li><p>Rendering Mode</p><ul><li><p>Smooth</p></li><li><p>Hinted Smooth</p></li><li><p>Hinted Raster</p><p>确保小字号的可读性</p></li><li><p>OS Default</p></li></ul></li><li><p>Character</p><ul><li><p>Dynamic</p><p>实现不生产字体纹理，需要的时候动态生成</p></li><li><p>Unicode</p></li><li><p>ASCII default set</p></li><li><p>ASCII upper case</p></li><li><p>ASCII lower case</p></li><li><p>Custom set</p></li></ul></li></ul><h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h3><h1 id="十、遮罩"><a href="#十、遮罩" class="headerlink" title="十、遮罩"></a>十、遮罩</h1><p>使用Mask组件后，可将附加的图像或文本作为这招，将其他的图形元素按照他们的形状来进行显示</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在Inspector面板中的Add Component中添加UI - Mask来创建这招</p><p>将要创建遮罩的元素图形作为已遮罩的图形元素的子元素后，将仅显示已遮罩的图形元素的形状的内测，它以外的部分将不做显示</p><ul><li><p>Show Mask Graphic</p><p>保持遮罩功能而不显示已遮罩的图像本身</p></li></ul><h2 id="纹理的格式-（另）"><a href="#纹理的格式-（另）" class="headerlink" title="纹理的格式 （另）"></a>纹理的格式 （另）</h2><p>Unity中使用的纹理，格式有JPEG,PNG,PSD等，发布时将作为纹理资源的Import Settings的Format中指定的格式。纹理的格式大致分为以下4类</p><ul><li><p>压缩格式</p><p>通过将图像压缩而所辖文件的大小的一种格式</p></li><li><p>16位格式</p><p>体积相比压缩格式文件较大，是一种适用于没有色阶图形的外观较好的格式</p></li><li><p>真彩色格式</p><p>以24位或32位来表现颜色的一种格式，画质最最好，文件最大，内存消耗高</p></li><li><p>Crunch压缩格式</p><p>通过Crunch压缩的一种画质较好，体积较小的DXT格式，仅在桌面平台使用</p></li></ul><p>*如果纹理是通过WWW类来下载的，一般会将JPEG转为RGB 24bit，PNG图像处理为ARGB 32bit，如果十通过WWW.LoadImageIntoTexture方法，则将JPEG处理位DXT1，PNG处理为DXT5</p><h1 id="十一、特效"><a href="#十一、特效" class="headerlink" title="十一、特效"></a>十一、特效</h1><p>渲染UI元素时，在传递顶点list给Canvas Renderer之前，通过对这些特效组件加以变更来应用特效</p><h2 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h2><p>使图形元素上浮并出现影子</p><ul><li>Effect Color</li><li>Effect Distance</li><li>Use Graphic Alpha</li></ul><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><p>为图形元素应用轮廓特效</p><p>Outline组件的类继承了Shadow组件的类，通过在四个方向应用Shadow来实现轮廓特效</p><ul><li>属性同上</li></ul><h2 id="Position-As-UV1"><a href="#Position-As-UV1" class="headerlink" title="Position As UV1"></a>Position As UV1</h2><p>Position As UV1组件是将图形元素顶点的坐标设置为各顶点的UV1*属性，通过着色器进行处理，据此就可以创建基于顶点坐标的自定义着色器</p><p>所构建的UI/Unlit/Detail着色器使用的就是该结构，可重叠显示材质Detail中设置的纹理进行显示</p><p>*Unity一共支持4套uv，在shader编程中，分别叫UV0, UV1, UV2, UV3，而在C#编程中分别叫UV, UV2, UV3, UV4</p><p>*UV0用于主纹理, UV1用于光照贴图, UV2用于实时动态光照, UV3可进行自定义</p><h2 id="协同程序（另）"><a href="#协同程序（另）" class="headerlink" title="协同程序（另）"></a>协同程序（另）</h2><p>方法执行通常都是在一帧内完成的，使用Coroutine的话就可以在方法执行过程中等待一定的时间或非同步处理完成</p><p>协同程序是通过一种返回值的类型为IEnumerator饼切在方法内还包括有yield return声明的方法，运行后在yield return声明的位置暂时重点处理，在满足一定的条件后再从终端的位置继续处理</p><p>e.g.</p><div class="hljs"><pre><code class="hljs C#">void Start(){// コルーチンの実行を開始するStartCoroutine(WaitAndGo(1.0f));Debug.Log("Waiting...");// ②}IEnumerator WaitAndGo(float duration){Debug.Log("Ready");// ①// 等待duration所指定的秒数yield return new WaitForSeconds(duration);Debug.Log("Go!");// ③}</code></pre></div><p>调用MonoBehavior的类的StartCoroutine方法，来开始运行协同程序。通过在yield return生命中返回 WaitForSeconds类的对象来暂时中断处理，等待指定的秒数后再继续进行处理，本实例中，将在控制台按照123顺序输入log</p><ul><li>tield return的生命中，除了可以通过WaitForSeconds类，还可以通过WaitForEndOfFrame类（等待帧）、WaitForFixedUpdate类（等待FixedUpdate方法被调用）的对象，等来恢复方法的处理</li></ul><h1 id="十二、UI元素的渲染与性能"><a href="#十二、UI元素的渲染与性能" class="headerlink" title="十二、UI元素的渲染与性能"></a>十二、UI元素的渲染与性能</h1><p>为了将对象渲染到画面中，Unity的渲染引擎对OpenGL，Direct3D等图形API发行了Draw Call</p><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>Unity可按特定的顺序再一帧内渲染多个多边形网络，由于渲染多边形网格分别依靠材质纹理等，会造成负荷变高，使用相同资源的多边形分组，尽量一次渲染调用来进行渲染，就可以大大提升效率，这种处理成为批处理（Batching）</p><p>资源变更中材质的变更伴随着色器的变更还需要重新构建内部的渲染状态，所以是非常缓慢的处理，这样的处理成为SetPass</p><ul><li>纹理的变更中着色器属性更新的部分其内部渲染状态并没有改变，只是增加了一次渲染调用，因此说并不像材质变更那样处理显得较为缓慢</li></ul><p>UI元素得批处理是分别再各自的Canvas（包括嵌套）中进行的</p><p>使用相同材质、相同纹理的元素被批处理了，但再渲染两个相同材质和纹理的元素期间还渲染了不同材质和纹理的元素时不进行批处理</p><p>如果各个元素没有重叠，可以通过Batch sorting结构进行优化处理，批量排序是可以集中渲染的没有重叠的UI元素的渲染顺寻进行自动变更，以使材质和纹理发生最低限度的变更的一种优化批处理的结构</p><h2 id="渲染的优化"><a href="#渲染的优化" class="headerlink" title="渲染的优化"></a>渲染的优化</h2><p>如上，变更材质与纹理时的负载较高，因此尽量减少变更次数才能实现性能的优化，例如仅为需要特殊效果的内容使用特别的材质，为众多的UI元素使用一种材质、Sprite也尽量集中于一个纹理图集中、不同字体的使用上要增加渲染调用等这些管控方法</p><p>Canvas上所有的图形元素都附加有Canvas Renderer组件，通过该组件就可以控制渲染。对图形元素所进行变更</p><p>层次结构变更也是一种复合负荷较高的处理，需要对画布上的所有图形元素进行重新计算，也伴随着批处理的重新计算。包括同一层级中的排序，也要尽力避免</p><h2 id="优化工具"><a href="#优化工具" class="headerlink" title="优化工具"></a>优化工具</h2><p>Unity中附带有助于优化和提高性能的编写工具</p><h3 id="渲染统计窗口"><a href="#渲染统计窗口" class="headerlink" title="渲染统计窗口"></a>渲染统计窗口</h3><p>Game视图中的Stats就可以显示渲染统计信息的重叠窗口</p><ul><li><p>帧滞后</p><p>显示当前的帧滞后（Frames Per Second/FPS）以及渲染Game识图一帧所需要的时间</p></li><li><p>Batches</p><p>显示批处理的最终渲染的调用次数，右侧显示由于批处理而减少使用渲染调用的次数</p></li><li><p>Tris、Verts</p><p>显示渲染的多边形与顶点数</p></li><li><p>Screen</p><p>显示画面的分辨率与内存的使用量</p></li><li><p>SetPass calls</p><p>显示材质变更的次数</p></li><li><p>Shader casters</p><p>显示渲染阴影处理的次数</p></li><li><p>Visible skinned meshes</p><p>先是通过Skinned Mesh Renderer进行渲染的蒙皮的次数</p></li><li><p>Animations</p><p>显示播放的动画的次数</p></li></ul><h3 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h3><p>在Windows菜单中可以打开Profiler显示性能分析</p><ul><li>CPU Usage</li><li>GPU Usage</li><li>Rendering</li><li>Memory</li><li>Audio</li><li>Physics</li><li>Physics 2D</li></ul><p>Rendering分析器中</p><ul><li>Batches （批处理次数）</li><li>SetPass calls （SetPass次数）</li><li>Triangles （多边形的数量）</li><li>Vertices （顶点的数量）</li></ul><h3 id="Frame-Debugger"><a href="#Frame-Debugger" class="headerlink" title="Frame Debugger"></a>Frame Debugger</h3><p>使用Frame Debugger可以对特定帧的渲染中所发生的所有渲染调用的详细信息进行单独确认</p><p>在Frame Debugger左侧有渲染调用和帧缓冲重置序列，可以确认渲染调用在何处以声明顺序发生，从左侧的列表选中渲染调用后，该通过的渲染调用多边形网格以及所使用的着色器等会显示与面板右侧，与此同时，在Game视图将会显示场景中所渲染调用是如何进行渲染的</p><p>上方的滑块和左右箭头按钮可以逐步前进或后退来对列表中序列的渲染顺序进行确认</p><h1 id="十三、交互UI元素"><a href="#十三、交互UI元素" class="headerlink" title="十三、交互UI元素"></a>十三、交互UI元素</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>交互UI元素有“Normal”、“Highlighted”、“Pressed”、“Disabled”的4种状态</p><ul><li><p>Normal</p><p>通常的状态，用户可以对次状态的UI元素进行选择或操作</p></li><li><p>Highlighted</p><p>鼠标指向UI元素时，UI元素被选中</p></li><li><p>Pressed</p><p>在UI元素上单机鼠标按钮或UI元素被触碰时的状态。通常情况下下UI元素会从Highlighted转化为Pressed状态，松开后恢复Highlighted</p></li><li><p>Disable</p><p>UI元素不能被选择或操作的状态</p><p>需要在交互组件的Inspector面板种，将Interactable属性取消勾选</p></li></ul><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>对UI元素采取操作时候，trigger会执行预先设置好的动作，我们将触发行为称为Event，将使之执行的动作称为Event Listener或者直接简称为Listener</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>Listener可以通过交互组件的Inspector面板设置，交互组件的Inspector面板下方有可以出发的事件监听器一览表， 加号就可以添加事件监听器的Entry</p><h4 id="事件监听器的运行模式"><a href="#事件监听器的运行模式" class="headerlink" title="事件监听器的运行模式"></a>事件监听器的运行模式</h4><ul><li><p>Off</p><p>不运行事件监听器</p></li><li><p>Editor And Runtime</p><p>无论Linstener在Edit模式还是Play模式都运行</p></li><li><p>Runtime Only</p><p>仅在Play模式中运行</p></li></ul><h4 id="对象字段"><a href="#对象字段" class="headerlink" title="对象字段"></a>对象字段</h4><p>拖拽并释放或运用对象拾取器设置运行某动作的对象</p><p>设置对象时，该对象所附加组件的类一览表会显示在Function List中</p><h4 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h4><p>显示对象字段中的对象所附加的组件的类一览表，选择类名称，即会显示该类定义的可执行动作列表</p><h4 id="参数字段"><a href="#参数字段" class="headerlink" title="参数字段"></a>参数字段</h4><p>当在功能列表中所选择的动作是带有参数的方法或属性时，设置传递给动作数值</p><hr><p>通过设置事件监听器，无需编写脚本可以运行事件对应的动作</p><p>如果设置了多个事件监听器，运行是按照从上到下的顺序</p><h2 id="自定义组件的事件监听器"><a href="#自定义组件的事件监听器" class="headerlink" title="自定义组件的事件监听器"></a>自定义组件的事件监听器</h2><p>可以内置组件类中定义的方法或属性，设置为事件监听器</p><p>在独立创建的自定义组件类中定义的方法火属性，也可以设置为事件监听器</p><h2 id="事件监听器的定义"><a href="#事件监听器的定义" class="headerlink" title="事件监听器的定义"></a>事件监听器的定义</h2><p>作为事件监听器设置方法或属性，需要符合以下条件中的任意一项</p><ul><li><p>没有参数，void public方法</p></li><li><p>有一个参数，void public方法</p><p>但是参数类型属于bool、int、float、string或者继承了含有GameObject或MonoBeHaviour的Object类</p></li><li><p>不是专门读取的public属性</p><p>但是，属性类型属于bool、int、float、string或者继承了含有GameObject或MonoBeHaviour的Object类</p></li></ul><p>不符合以上条件的方法或属性，不能显示在功能列表中，因此不能设置为事件监听器</p><p>静态的方法或属性也不能作为事件监听器设置的</p><p>示例</p><div class="hljs"><pre><code class="hljs C#">//可以设置为事件监听器的属性public bool BoolExample { get; set;}public int IntExample { get; set;}public float FloatExample { get; set;}public string StringExample { get; set;}public RectTransform RectTransformExample { get; set;}//可以设置为事件监听器的方法public void OnExample(){}public void OnExample(bool param){}public void OnExample(int param){}public void OnExample(float param){}public void OnExample(String param){}public void OnExample(RectTransform param){}//不能设置为事件监听器的属性public int IntReadOnlyExample  { get{ return 1; }} //读取专用public int[] IntArrayExample  { get; set;} //数组public double DoubleExample { get; set;} //double形public Rect RectExample { get; set;} //结构体public KeyCode KeyCodeExample { get; set;} //列举形public System.Array ArrayExample { get; set;} //不继承Object类//不能设置为事件监听器的方法public int OnExampleInt() { return 1;} //有返回值public void OnExample(Int[] param){} //参数为数组public void OnExample(int param1,int param2){} //参数为数组public void OnExample(Rect param){} //参数为结构体public void OnExample(KeyCode param){} //参数为列举形public void OnExample(System.Array param){} //参数是没有继承Object类的类</code></pre></div><h2 id="通过脚本设置事件"><a href="#通过脚本设置事件" class="headerlink" title="通过脚本设置事件"></a>通过脚本设置事件</h2><p>通过脚本设置事件需要使用交互组件事件属性中定义的AddListener方法，例如Button组件需要通过Button类的onClick属性的AddListener方法添加事件监听器</p><div class="hljs"><pre><code class="hljs C#">[SerializeField] private Button button;void Start(){    button.onClick.AddListener(OnClickButton);}public void OnClickButton(){Debug.Log("Button is clicked.");    }</code></pre></div><p>Button类的onClick属性是Button.ButtonClickedEvent类。在Button.ButtonClickedEvent类的AddListener方法中，不能将有参数的方法设置为事件监听器，如下</p><div class="hljs"><pre><code class="hljs C#">//一个错误的示例[SerializeField] private Button button;void Start(){    button.onClick.AddListener(OnClickButton);}public void OnClickButton(Button sender){Debug.Log(sender.name + "is clicked");    }</code></pre></div><p>在这种情况下，需要使用lambda表达式传递参数</p><p>按照以下编写代码的话，有序lambda表达式本身没有参数，所以可以在Button.ButtonClickedEvent类的AddListener方法中，作为事件监听器设置，也能像有参数的方法传递参数了。</p><div class="hljs"><pre><code class="hljs C#">//正确的示例[SerializeField] private Button button;void Start(){    button.onClick.AddListener(()=OnClickButton);}public void OnClickButton(Button sender){Debug.Log(sender.name + "is clicked");    }</code></pre></div><p>而且，如陈述形式的lambda表达式编写，可以将运行的处理与AddListener方法编写在同一个区域里，虽然如果使用过多的话会让源代码看上去不那么清晰，但是可以让稍微复杂的处理编写简单</p><div class="hljs"><pre><code class="hljs C#">//正确的示例[SerializeField] private Button button;void Start(){    button.onClick.AddListener(()=>{        Debug.Log(button.name + "is clicked.");    });}</code></pre></div><h2 id="Event-Trigger"><a href="#Event-Trigger" class="headerlink" title="Event Trigger"></a>Event Trigger</h2><p>原本不是交互组件的不能设置为事件监听器，需要使用Event Trigger</p><p>附加有Event Trigger组件的对象就可以接受事件系统发出的所有时间，出发该事件，就能执行预先设定好的动作了</p><p>*附加了Event Trigger组件的对象，会补货所有的事件，因此事件无法发送到位于此对象背后的对象上</p><p><strong>使用方法 略</strong></p><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><ul><li>按钮的构造是，一个Button内部对象包含一个Text对象，附加了Button组件</li><li>Button对象是作为背景图案的图形，Text对象是作为按钮标签的文本</li></ul><h3 id="Button的事件"><a href="#Button的事件" class="headerlink" title="Button的事件"></a>Button的事件</h3><p>当button被按下松开时，就会出发On Click()事件。只有当按下与松开都是在同一个按钮上进行的时候，才会触发OnClick()事件</p><p>用脚本设置事件监听器的话，使用Button类的onClick属性(Button.ButtonClickedEvent 类)的AddListener方法。用~可以将没有参数的方法作为事件监听器来设置</p><div class="hljs"><pre><code class="hljs C#">[SerializeField] private Button button;void Start(){    button.onClick.AddListener(OnClickButton);}public void OnClickButton(){Debug.Log("Button is clicked.");    }</code></pre></div><h2 id="Toggle"><a href="#Toggle" class="headerlink" title="Toggle"></a>Toggle</h2><p>Toggle是一个很像按钮的UI元素，用户每次按压就会在ON和OFF两个状态之间切换，可以作为开关或者复选框</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>Toggle包含着Background对象和Label对象，同时附加了Toggle组件</p><p>Background还包含着Checkmark对象，这是作为Toggle背景的图像</p><p>Checkmark对象是重叠显示在Background对象上的复选框，与切换开关的ON/OFF状态联动切换显示/非现实</p><h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><ul><li><p>Is On</p><p>当Is On属性为On时显示勾选，反之不勾选，从On -> OFF -> On的状态切换</p></li><li><p>Toggle Transition</p><p>可以设置当前勾选符号切换时候的效果</p><p>None就立即切换</p><p>Fade会有淡入淡出的效果</p></li><li><p>Graphic</p><p>与Is On属性联动，指定作为复选框显示/非显示的图像</p></li><li><p>Group</p><p>指定切换开关所属的组</p></li></ul><h3 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h3><p>当按下并松开Toggle时，就会触发On Value Changed(Boolean)</p><h4 id="事件监听器设置"><a href="#事件监听器设置" class="headerlink" title="事件监听器设置"></a>事件监听器设置</h4><p>On Value Changed(Boolean)功能以列表有Dynamic bool（动态布尔型），和Static Parameters（静态参数形）两类（有的组件没有Dynamic bool）。Dynamic bool的一览表中，显示了处理真假值（布尔型）的方法属性</p><ul><li>真假值：True / False的值</li></ul><p>如果将使用Dynamic bool的方法或属性设置为事件监听器的话，会自动地将Is On属性的值传递过去，固入口处就不会显示参数字段了</p><p>例如GameObject的SetActive设置为世家年同期，就可以和toggle的On/Off联动，切换目标对象活动或者不活动的状态</p><p>即使是相同的GameObject的SetActive方法，如果将Static Parameters设置为事件监听器的话，向事件监听器传递的值就与Is On的属性无关，而是将参数字段中设置的值传递过去</p><h4 id="运用脚本设置事件监听器"><a href="#运用脚本设置事件监听器" class="headerlink" title="运用脚本设置事件监听器"></a>运用脚本设置事件监听器</h4><p>需要使用Toggle的onValueChanged的AddListener方法，能够将带有布尔型参数的方法设置为事件监听器，Is On属性的值就传递给参数</p><div class="hljs"><pre><code class="hljs C#">[SerializeField] private Toggle toggle;void Start(){    toggle.onValueChanged.AddListener(OnToggle);}public void OnToggle(bool value){    Debug.Log("Toggle value is " + value.ToString());}</code></pre></div><h3 id="切换开关组"><a href="#切换开关组" class="headerlink" title="切换开关组"></a>切换开关组</h3><p>使用Toggle Group组件将切换开关设置为组的话，当组内的任意一个切换开关为On时，其他的切换开关全部处于Off状态，也就是单选按钮</p><ul><li>使用单选按钮</li></ul><p>船舰EmptyObject，命名为Toggle Group，然后为其附加toggle group组件</p><p>船舰为单选钮的toggle，设置为Toggle Group对象的子元素，同时在组件里绑定这些对象</p><h4 id="属性-5"><a href="#属性-5" class="headerlink" title="属性"></a>属性</h4><p>Allow Switch Off，如果属性为O女的话，唯一为On的切换开关可以自由关闭</p><h2 id="作为协同程序的事件方法（另）"><a href="#作为协同程序的事件方法（另）" class="headerlink" title="作为协同程序的事件方法（另）"></a>作为协同程序的事件方法（另）</h2><p>Start和Update等事件方法，通过将返回值类型设置为IEnumerator，就能作为协同程序执行，此时没有必要调用StartCorountine方法，还有，Awake方法不能当做协同程序执行。</p><div class="hljs"><pre><code class="hljs C#">IEnumerator Start(){    yield return new WaitForSeconds(1.0f);    //最初等待一秒钟，显示“Start”    Debug.Log("Start");}</code></pre></div><h2 id="Slider"><a href="#Slider" class="headerlink" title="Slider"></a>Slider</h2><p>Slider是用于调整BGM或效果音的音量等连续数值</p><h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><p>滑块是附加了Slider组件的Slider对象，包含了Background对象、Fill Area对象和Handle Slide Area对象</p><ul><li><p>Background</p><p>是作为滑块背景的图像</p></li><li><p>FillArea</p><p>包含了Fill对象，通过操作滑块，在拖动手柄与最小值一侧顶端伸缩的图像</p></li><li><p>Handle Slide Area</p><p>包含了Handle对象，用户可以操作的拖动手柄，定义拖动手柄可移动的范围</p></li></ul><h3 id="属性-6"><a href="#属性-6" class="headerlink" title="属性"></a>属性</h3><ul><li><p>Fill Rect</p><p>在Fill Rect中，指定通过滑块操作拖动手柄与最小侧一端之间伸缩的对象(Rect Transform)。指定为None则可以设置为没有Fill Rect的滑块</p></li><li><p>Handle Rect</p><p>设置作为拖动手柄的对象(Rect Transform)。指定为None，则可以设置为没有拖动手柄的滑块（即使没有拖动手柄也能进行操作）</p><p>多用于显示进度，生命值，经验值等计量仪使用，所以关闭interactable</p></li><li><p>Direction</p><ul><li>Left To Right</li><li>Right To Left</li><li>Bottom To Top</li><li>Top To Bottom</li></ul></li><li><p>Min Value\Max Value</p></li><li><p>Whole Numbers </p><p>只会获得整数</p></li><li><p>Value</p><p>初始值，值得范围来自Min Value 和 Max Value</p></li></ul><h3 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h3><p>当操作滑块时，导致Value属性的值发生变化，就出发了On Value Changed(single)事件，只能处理0.5或1.0这样的实数值</p><h4 id="事件监听器的设置"><a href="#事件监听器的设置" class="headerlink" title="事件监听器的设置"></a>事件监听器的设置</h4><p>On Value Changed(single)列表分为Dynamic float和Static Parameters两类，在Dynamic float的一览表中，显示着处理float的方法和属性，将使用Dynamic float的方法和属性设置为事件监听器的话就能自动传递Value属性的值</p><h4 id="运用脚本设置事件监听器-1"><a href="#运用脚本设置事件监听器-1" class="headerlink" title="运用脚本设置事件监听器"></a>运用脚本设置事件监听器</h4><p>同样使用AddListener方法</p><p>使用此方法，可以将带有浮点型参数的方法设置为事件监听器</p><div class="hljs"><pre><code class="hljs C#">[SerializeField] private Slider slider;void Start(){    slider.onValueChanged.AddListener(OnSlide);}public void OnSlide(float value){    Debug.Log("Slider value is " + value.ToString());}</code></pre></div><h2 id="Scrollbar"><a href="#Scrollbar" class="headerlink" title="Scrollbar"></a>Scrollbar</h2><p>Scrollbar与Slider一样，通过拖动手柄操作的UI元素，主要用于操作滚动视图</p><p>不同点</p><ul><li>没有类似滑动操作而伸缩的Fill Rect对象</li><li>拖动手柄的大小是可变的，根据拖动手柄的大小可以判断出当前显示的内容占滚动视图的比例</li><li>相对于滑块是通过min Value和max Value来设置处理范围值的，滚动条的值范围通常固定为0.0~1.0之间</li></ul><h3 id="构造-2"><a href="#构造-2" class="headerlink" title="构造"></a>构造</h3><p>滚动条的构造类似于没有Fill Area的Slider，附加了Scrollbar组件和Image组件的Scrollbar对象</p><p>Sliding Area对象是Scrollbar整体背景的图像，而且包含了用户可以操作的Handle对象，用于定义拖动手柄可移动的范围</p><h3 id="属性-7"><a href="#属性-7" class="headerlink" title="属性"></a>属性</h3><ul><li><p>Handle Rect</p><p>与滑块不同，滚动条的Handle Rect属性是必须要设置的</p></li><li><p>Direction</p></li><li><p>Value</p></li><li><p>Size</p></li><li><p>Number Of Steps</p><p>设置拖动手柄时，分为几个阶段捕捉数据。值得范围是0~11，当设置为0或1时，不捕捉。</p><p>如果将Numbers Of Steps属性设置为3的话，则在0.0、0.5、1.0三个阶段捕捉</p></li></ul><h3 id="事件-3"><a href="#事件-3" class="headerlink" title="事件"></a>事件</h3><p>操作Scrollbar时，Value属性的值发生变化，会触发On Value Changed(Single) 事件</p><h4 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h4><p>On Value Changed(Single)事件的事件监听器功能列表分别为Dynamic float和Static Parameters两类</p><p>在Dynamic float的一览表中，显示着处理实数值(float浮点型)的方法和属性。将使用Dynamic float的方法和属性设置为事件监听器，就会自动传递Value属性的值</p><h4 id="脚本设置事件监听器"><a href="#脚本设置事件监听器" class="headerlink" title="脚本设置事件监听器"></a>脚本设置事件监听器</h4><p>同样使用AddListener方法</p><div class="hljs"><pre><code class="hljs C#">[SerializeField]private Scrollbar scrollbar;void Start(){    scrollbar.onValueChanged.AddListener(OnScroll);}public void OnScroll(float value){    Debug.Log("scrollbar value is " + value.ToString());}</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;UGUI 相关学习记录（最后更新：1.15），目前：画布；Rect Transform 组件；Event System组件；Image；Sprite Editor；Sprite Packer；Sprite Atlas；Raw Image；Text；Mask；特效；UI元素的渲染与性能&lt;/p&gt;</summary>
    
    
    
    
    <category term="Unity" scheme="http://yancc.cc/tags/Unity/"/>
    
    <category term="UGUI" scheme="http://yancc.cc/tags/UGUI/"/>
    
  </entry>
  
  <entry>
    <title>2021新年</title>
    <link href="http://yancc.cc/2021/01/01/2021Year/"/>
    <id>http://yancc.cc/2021/01/01/2021Year/</id>
    <published>2021-01-01T04:21:35.000Z</published>
    <updated>2021-01-07T09:35:19.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新年愿望"><a href="#新年愿望" class="headerlink" title="新年愿望"></a>新年愿望</h1><p>希望可以健健康康的度过2021年。</p><a id="more"></a><ul><li><input disabled type="checkbox"> <p>找到一份满意的实习</p></li><li><input disabled type="checkbox"> <p>可以一个人生活</p></li><li><input disabled type="checkbox"> <p>维系社交关系</p></li><li><input disabled type="checkbox"> <p>学会Lua / Python</p></li><li><input disabled type="checkbox"> <p>认真的记录生活</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;新年愿望&quot;&gt;&lt;a href=&quot;#新年愿望&quot; class=&quot;headerlink&quot; title=&quot;新年愿望&quot;&gt;&lt;/a&gt;新年愿望&lt;/h1&gt;&lt;p&gt;希望可以健健康康的度过2021年。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://yancc.cc/tags/日常/"/>
    
  </entry>
  
  <entry>
    <title>C# 查缺补漏</title>
    <link href="http://yancc.cc/2020/12/30/Csharp-Learning/"/>
    <id>http://yancc.cc/2020/12/30/Csharp-Learning/</id>
    <published>2020-12-30T15:23:47.000Z</published>
    <updated>2021-01-07T09:54:53.449Z</updated>
    
    <content type="html"><![CDATA[<p>C# 查缺补漏专栏，持续更新</p><a id="more"></a><h1 id="2020-08-06-更新："><a href="#2020-08-06-更新：" class="headerlink" title="2020.08.06 更新："></a>2020.08.06 更新：</h1><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><div class="hljs"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">"{0}+{1}={2}"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);</code></pre></div><h2 id="使用-不识别转义字符"><a href="#使用-不识别转义字符" class="headerlink" title="使用@不识别转义字符"></a>使用@不识别转义字符</h2><p>如果不想识别字符串中的转义字符，可以在字符串前面加一个@符号（除双引号外，如果表一个双引号则需要两个）</p><ul><li>使用场景多在表示路径</li><li>把一个字符串定义在多行</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>ctrl+k ctrl+c 注释选中行</li><li>ctrl+k ctrl+u 取消注释选中行</li></ul><blockquote><p>2020.08.08 更新：</p></blockquote><h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>C#中将string类型转换为float类型时，不应该使用Convert.ToFloat()方法，正确的方法为Convert.ToSingle()</p><p>查了一下，在C#的基类库中single是浮点的名称，float为别名</p><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&和&&的区别"></a>&和&&的区别</h2><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>通过定义标签直接控制程序跳转到标签位置</p><p>缺点：</p><ul><li>降低代码可读性</li><li>使得代码复杂</li><li>和程序访问的局部性原理相违背</li></ul><h1 id="2020-12-30"><a href="#2020-12-30" class="headerlink" title="2020.12.30"></a>2020.12.30</h1><p>今天又忘了C#里没有Convert.ToFloat，只有Convet.ToSingle。</p><h1 id="2020-12-31"><a href="#2020-12-31" class="headerlink" title="2020.12.31"></a>2020.12.31</h1><h2 id="属性和字段的比较"><a href="#属性和字段的比较" class="headerlink" title="属性和字段的比较"></a>属性和字段的比较</h2><ul><li>属性可以实现只读或只写，字段不行</li><li>属性的set方法可以对用户指定的value，进行有效检查，从而保证只有正确的状态才会得到设置，字段不行</li><li>属性的get方法不仅可以返回字段变量的值，可以返回一些经过计算或处理过的数据</li><li>由于属性在实现时，实际上是方法，所以可以具有方法的一些优点</li></ul><h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><ul><li>在类的内部记录事物的状态信息，则用字段变量</li><li>字段变量一般用private修饰，以防止对外使用</li><li>对外公布事物的状态信息，则使用属性</li><li>属性一般与某个或某几个字段变量有对应关系</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;C# 查缺补漏专栏，持续更新&lt;/p&gt;</summary>
    
    
    
    
    <category term="C#" scheme="http://yancc.cc/tags/C/"/>
    
    <category term="暑期学习" scheme="http://yancc.cc/tags/暑期学习/"/>
    
  </entry>
  
  <entry>
    <title>从Mac迁移Hexo至Windows</title>
    <link href="http://yancc.cc/2020/09/11/%E4%BB%8EMac%E8%BF%81%E7%A7%BBHexo%E8%87%B3Windows/"/>
    <id>http://yancc.cc/2020/09/11/%E4%BB%8EMac%E8%BF%81%E7%A7%BBHexo%E8%87%B3Windows/</id>
    <published>2020-09-11T04:58:20.000Z</published>
    <updated>2021-01-07T09:36:47.951Z</updated>
    
    <content type="html"><![CDATA[<p>害挺麻烦的。</p><a id="more"></a><p>= =#，都忘了这回事了，大概说说流程。</p><ol><li>安装Git </li><li>弄好SSH key </li><li>安装Node.js（🕳，这里不能安装过高的版本）</li><li>安装hexo </li><li>把源Hexo文件夹拷贝到新电脑中</li><li>切到拷贝过来的文件夹，npm install</li><li>安装核心组件<ul><li>hexo-deployer-git </li><li>hexo-generator-feed</li><li>hexo-generator-sitemap </li></ul></li><li>hexo g -d 部署完成，迁移成功</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;害挺麻烦的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://yancc.cc/tags/日常/"/>
    
    <category term="小技巧" scheme="http://yancc.cc/tags/小技巧/"/>
    
  </entry>
  
  <entry>
    <title>Unity官方课程学习记录 2020.07.20-22</title>
    <link href="http://yancc.cc/2020/07/20/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.20-22/"/>
    <id>http://yancc.cc/2020/07/20/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.20-22/</id>
    <published>2020-07-20T06:16:28.000Z</published>
    <updated>2021-01-07T06:57:10.705Z</updated>
    
    <content type="html"><![CDATA[<p>老阶段性测试了+水果忍者原型实现，完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</p><a id="more"></a><h1 id="Day-7-踢足球-阶段性测试"><a href="#Day-7-踢足球-阶段性测试" class="headerlink" title="Day 7 踢足球 + 阶段性测试"></a>Day 7 踢足球 + 阶段性测试</h1><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>滚动操作球，把对方的球踢入它的球门</li><li>敌人全部消失后进入下一个场，每场多一个</li><li>滚动冲刺</li><li>粒子效果</li><li>增益buff</li></ul><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/img/u4c0.gif" srcset="/img/loading.gif" alt="效果图"></p><h2 id="Debug方式"><a href="#Debug方式" class="headerlink" title="Debug方式"></a>Debug方式</h2><ul><li>优先运行游戏运行时控制台的报错，再讨论机制问题</li></ul><h2 id="官方测试题"><a href="#官方测试题" class="headerlink" title="官方测试题"></a>官方测试题</h2><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><img src="/img/u4c1.png" srcset="/img/loading.gif" alt="1"></p><h3 id="答案：D"><a href="#答案：D" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="/img/u4c2.png" srcset="/img/loading.gif" alt="2"></p><h3 id="答案：B"><a href="#答案：B" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><img src="/img/u4c3.png" srcset="/img/loading.gif" alt="3"></p><h3 id="答案：A"><a href="#答案：A" class="headerlink" title="答案：A"></a>答案：A</h3><h3 id="解析：b里面的-变成-，vector3中只可以使用乘，唯有A可以解决报错"><a href="#解析：b里面的-变成-，vector3中只可以使用乘，唯有A可以解决报错" class="headerlink" title="解析：b里面的=变成+，vector3中只可以使用乘，唯有A可以解决报错"></a>解析：b里面的=变成+，vector3中只可以使用乘，唯有A可以解决报错</h3><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p><img src="/img/u4c4.png" srcset="/img/loading.gif" alt="4"></p><h3 id="答案：A-1"><a href="#答案：A-1" class="headerlink" title="答案：A"></a>答案：A</h3><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><img src="/img/u4c5.png" srcset="/img/loading.gif" alt="5"></p><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><img src="/img/u4c6.png" srcset="/img/loading.gif" alt="6"></p><h3 id="答案：D-1"><a href="#答案：D-1" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p><img src="/img/u4c7.png" srcset="/img/loading.gif" alt="7"></p><h3 id="答案：B-1"><a href="#答案：B-1" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p><img src="/img/u4c8.png" srcset="/img/loading.gif" alt="8"></p><h3 id="答案：B-2"><a href="#答案：B-2" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p><img src="/img/u4c9.png" srcset="/img/loading.gif" alt="9"></p><h3 id="答案：D-2"><a href="#答案：D-2" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><img src="/img/u4cX.png" srcset="/img/loading.gif" alt="10"></p><h3 id="答案：E"><a href="#答案：E" class="headerlink" title="答案：E"></a>答案：E</h3><hr><h1 id="Day-8-水果忍者原型实现"><a href="#Day-8-水果忍者原型实现" class="headerlink" title="Day 8 水果忍者原型实现"></a>Day 8 水果忍者原型实现</h1><p>今天开发的是一个水果忍者游戏的原型，马上这个系列的课就学完了，终于要开始下一阶段的学习了！</p><!-- more --><h2 id="游戏实现-1"><a href="#游戏实现-1" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>一个简易的开始菜单，可以选择难度</li><li>一个简易的Game Over菜单</li><li>会从屏幕下方弹出水果和炸弹，点到水果会加分，点到炸弹会扣分</li><li>当水果没有被点到且掉出下方边界时候，游戏结束</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>通过创建SpawnManager来控制随机物品的生成</li><li>设置游戏选择难度按钮，选择难度后SpawnManager开始生成</li><li>通过设置一条触发器来判断游戏结束</li><li>游戏结束时候会弹出GameOver的信息以及restart按钮</li></ul><h2 id="GameManager"><a href="#GameManager" class="headerlink" title="GameManager"></a>GameManager</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> TMPro;<span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> List<GameObject> targetPrefebs; <span class="hljs-comment">//list列表 可以用add，remove方法添加或删除</span>  <span class="hljs-comment">//public GameObject[] target;          //数组 占用固定的内存无法添加</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">10.0f</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> spawnRate = <span class="hljs-number">1.0f</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> gameStarted;    <span class="hljs-keyword">public</span> TextMeshProUGUI scoreText;    <span class="hljs-keyword">public</span> GameObject gameOver;    <span class="hljs-keyword">public</span> GameObject mainMenu;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-function">IEnumerator <span class="hljs-title">SpawnTarget</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">while</span> (gameStarted)        {            <span class="hljs-function"><span class="hljs-keyword">yield</span> return new <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">spawnRate</span>)</span>;            <span class="hljs-keyword">int</span> index = Random.Range(<span class="hljs-number">0</span>, targetPrefebs.Count);            Instantiate(targetPrefebs[index]);        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateSource</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> scoreToAdd</span>)</span>    {        score += scoreToAdd;        scoreText.text = <span class="hljs-string">"Score:"</span> + score;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameIsOver</span>(<span class="hljs-params"></span>)</span> {        gameStarted = <span class="hljs-literal">false</span>;        gameOver.SetActive(<span class="hljs-literal">true</span>);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RestartGame</span>(<span class="hljs-params"></span>)</span>     {        SceneManager.LoadScene(SceneManager.GetActiveScene().name);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartNewGame</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> switchD</span>)</span> {        spawnRate /= switchD;        gameStarted = <span class="hljs-literal">true</span>;        StartCoroutine(SpawnTarget());        mainMenu.SetActive(<span class="hljs-literal">false</span>);    }}</code></pre></div><h3 id="数组与ArrayList与List"><a href="#数组与ArrayList与List" class="headerlink" title="数组与ArrayList与List"></a>数组与ArrayList与List</h3><ul><li>数组<ul><li>内存中是连续存储的，所以它的索引速度非常快，而且赋值与修改元素也很简单</li><li>不足：<ul><li>需要指定长度，当长度过长时会造成内存浪费</li><li>如果不确定长度的时候也会很麻烦</li></ul></li></ul></li><li>ArrayList<ul><li>命名空间System.Collections下的一部分，在使用该类时必须进行引用</li><li>继承了IList接口，提供了数据存储和检索</li><li>ArrayList对象的大小是按照其中存储的数据来动态扩充与收缩的，不需要指定长度</li><li>不足：<ul><li>ArrayList不是类型安全的</li><li>存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损</li></ul></li></ul></li><li>List<ul><li>List类是ArrayList类的泛型等效类</li><li>大部分用法都与ArrayList相似，因为List类也继承了IList接口</li><li>在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</li></ul></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    GameManager gameManager;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> point;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> miniSpeed = <span class="hljs-number">12</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> maxSpeed = <span class="hljs-number">16</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> maxTorque = <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> xRange = <span class="hljs-number">4</span>;    <span class="hljs-keyword">public</span> ParticleSystem explosionParticle;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        gameManager = FindObjectOfType<GameManager>();        rb = GetComponent<Rigidbody>();        rb.AddForce(RandomSpeed(), ForceMode.Impulse);        rb.AddTorque(RandomTorque(), RandomTorque(), RandomTorque());        transform.position = RandomSpawnPos();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>    {        Destroy(gameObject);        <span class="hljs-keyword">if</span> (!gameObject.CompareTag(<span class="hljs-string">"Bad"</span>))        {            gameManager.GameIsOver();        }          }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (gameManager.gameStarted)        {            Instantiate(explosionParticle, transform.position, explosionParticle.transform.rotation);            gameManager.UpdateSource(point);            Destroy(gameObject);        }            }    <span class="hljs-function">Vector3 <span class="hljs-title">RandomSpeed</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">return</span> Vector3.up * Random.Range(miniSpeed, maxSpeed); <span class="hljs-comment">// 因为乘了vector3.up 所以有个初始值</span>    }    <span class="hljs-function">Vector3 <span class="hljs-title">RandomSpawnPos</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(Random.Range(-xRange, xRange), <span class="hljs-number">-1f</span>, <span class="hljs-number">0</span>);    }    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">RandomTorque</span>(<span class="hljs-params"></span>)</span> {        <span class="hljs-keyword">return</span> Random.Range(-maxTorque, maxTorque);    }}</code></pre></div><h2 id="SwitchDifficulty"><a href="#SwitchDifficulty" class="headerlink" title="SwitchDifficulty"></a>SwitchDifficulty</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> UnityEngine.UI;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwithcDifficulty</span> : <span class="hljs-title">MonoBehaviour</span>{    Button button;    GameManager gameManager;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> difficulty;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        button = GetComponent<Button>();        gameManager = FindObjectOfType<GameManager>();        button.onClick.AddListener(SetDifficulty);    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDifficulty</span>(<span class="hljs-params"></span>)</span> {        gameManager.StartNewGame(difficulty);    }}</code></pre></div><h2 id="Rigidbody-AddTorque"><a href="#Rigidbody-AddTorque" class="headerlink" title="Rigidbody.AddTorque"></a>Rigidbody.AddTorque</h2><ul><li>向刚体添加扭矩</li><li>只能应用于处于活动状态的刚体。如果 GameObject 处于非活动状态，则 AddTorque 没有效果</li><li>默认将唤醒刚体。如果扭矩大小为零，则不会唤醒刚体</li><li>添加prefeb不能一起添加，只能一个一个添加</li><li>更改变量类型后要回到面板看看数值有没有丢失</li></ul><h2 id="GameManager-1"><a href="#GameManager-1" class="headerlink" title="GameManager"></a>GameManager</h2><h2 id="OnMouseDown"><a href="#OnMouseDown" class="headerlink" title="OnMouseDown()"></a>OnMouseDown()</h2><ul><li>在移动平台也可以用</li><li>物体要有碰撞器才有效果</li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ul><li>画布 (Canvas) 是应该容纳所有 UI 元素的区域</li><li>画布是一种带有画布组件的游戏对象</li><li>所有 UI 元素都必须是此类画布的子项<ul><li>如果场景中没有画布，那么创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下</li></ul></li></ul><h3 id="TEXT-TMP"><a href="#TEXT-TMP" class="headerlink" title="TEXT TMP"></a>TEXT TMP</h3><ul><li>命名空间：</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> TMPro;</code></pre></div><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><ul><li>需引入命名空间：</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;</code></pre></div><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><h3 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h3><ul><li>用来适应不同的屏幕大小</li><li>留坑() 以后看UGUI的时候再回来补</li></ul><h2 id="场景重载"><a href="#场景重载" class="headerlink" title="场景重载"></a>场景重载</h2><ul><li>命名空间</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement</code></pre></div><p>LoadScene(string)传入场景名称，达到载入场景的效果</p><p>gameObject.GetActiveScene().name，获得物体的场景，可直接传入LoadScene()以达到重新开始的效果</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>添加prefeb不能一起添加，只能一个一个添加</li><li>更改变量类型后要回到面板看看数值有没有丢失</li></ul><hr><h1 id="Day-9-修修补补，课程完结"><a href="#Day-9-修修补补，课程完结" class="headerlink" title="Day 9 修修补补，课程完结"></a>Day 9 修修补补，课程完结</h1><h2 id="游戏实现-2"><a href="#游戏实现-2" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>有倒计时，获得尽可能高的分数</li><li>当忘记点了good物体则游戏失败</li><li>难度选择以及重新开始</li></ul><h2 id="Mathf-Round"><a href="#Mathf-Round" class="headerlink" title="Mathf.Round"></a>Mathf.Round</h2><ul><li>四舍六入五取偶数</li></ul><h2 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h2><ul><li>在Hierarchy面板中，按住 <code>Alt</code> 可以打开一个物体的所有的子目录</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;老阶段性测试了+水果忍者原型实现，完结撒花&lt;em&gt;★,°&lt;/em&gt;:.☆(￣▽￣)/$:&lt;em&gt;.°★&lt;/em&gt; 。&lt;/p&gt;</summary>
    
    
    
    
    <category term="暑期学习" scheme="http://yancc.cc/tags/暑期学习/"/>
    
    <category term="Unity" scheme="http://yancc.cc/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity官方课程学习记录 2020.07.16-19</title>
    <link href="http://yancc.cc/2020/07/16/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.16-19/"/>
    <id>http://yancc.cc/2020/07/16/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.16-19/</id>
    <published>2020-07-16T11:59:18.000Z</published>
    <updated>2021-01-07T06:57:04.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day-4-跑酷小游戏"><a href="#Day-4-跑酷小游戏" class="headerlink" title="Day 4 跑酷小游戏"></a>Day 4 跑酷小游戏</h1><p>一个跑酷的小游戏和滚动小球儿，感觉还挺有趣的。</p><p>内附10道测试题。</p><a id="more"></a><h2 id="游戏要实现的功能"><a href="#游戏要实现的功能" class="headerlink" title="游戏要实现的功能"></a>游戏要实现的功能</h2><p>玩家通过 <code>空格</code> 实现跳跃，完成跨越障碍的动作，如果碰到障碍则游戏结束输出game over，同时需要有特效和音乐音效</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ul><li>通过给player添加脚本实现跳跃跨越障碍，游戏结束判定</li><li>通过给Ground和Background添加脚本设置背景后移</li><li>设置spawnManager以及脚本用来生成障碍</li></ul><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    <span class="hljs-keyword">private</span> Animator anim;<span class="hljs-comment">//获得动画组件</span>    <span class="hljs-keyword">private</span> AudioSource audioSource;<span class="hljs-comment">//获得声音组件</span><span class="hljs-keyword">public</span> AudioClip crashClip, jumpClip;<span class="hljs-comment">//获得声音clip</span>    <span class="hljs-keyword">public</span> ParticleSystem dirtParticle, expParticle; <span class="hljs-comment">//特效</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> gravitymodifier; <span class="hljs-comment">//缓慢落下，设置重量变量</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> jumpForce;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> isGround;<span class="hljs-comment">// 默认为false</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isGameOver;<span class="hljs-comment">//判断游戏结束</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        rb = GetComponent<Rigidbody>();anim = GetComponent<Animator>();audioSource = GetComponent<AudioSource>();        Physics.gravity *= gravitymodifier;<span class="hljs-comment">//增加下落重力</span>    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space) && isGround)        {            rb.AddForce(Vector3.up * jumpForce , ForceMode.Impulse);            isGround = <span class="hljs-literal">false</span>;            anim.SetTrigger(<span class="hljs-string">"Jump_trig"</span>);<span class="hljs-comment">//设置跳跃动画触发器</span>            dirtParticle.Stop();<span class="hljs-comment">//跳跃时候终止粒子特效播放</span>            audioSource.PlayOneShot(jumpClip, <span class="hljs-number">1f</span>);        }    }    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)<span class="hljs-comment">//跳跃检测</span></span>    {        <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">"Ground"</span>))        {            isGround = <span class="hljs-literal">true</span>;            dirtParticle.Play();<span class="hljs-comment">//当落地时，粒子特效播放</span>        }        <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">"Obstacle"</span>)) /        {            isGameOver = <span class="hljs-literal">true</span>;<span class="hljs-comment">//当碰撞物体时，停止物体生成，停止背景地板后退</span>            isGround = <span class="hljs-literal">false</span>;<span class="hljs-comment">//停止跳跃功能</span>            audioSource.PlayOneShot(crashClip,<span class="hljs-number">1f</span>);<span class="hljs-comment">//播放死亡音效</span>            Debug.Log(<span class="hljs-string">"Game Over"</span>);<span class="hljs-comment">//播放死亡动画</span>            anim.SetBool(<span class="hljs-string">"Death_b"</span>,<span class="hljs-literal">true</span>);            anim.SetInteger(<span class="hljs-string">"DeathType_int"</span>,<span class="hljs-number">2</span>);             <span class="hljs-comment">//播放死亡特效，奔跑特效停止</span>            expParticle.Play();            dirtParticle.Stop();        }    }}</code></pre></div><h3 id="Rigibody-AddForce"><a href="#Rigibody-AddForce" class="headerlink" title="Rigibody.AddForce"></a>Rigibody.AddForce</h3><p>添加一个力量到钢体</p><ul><li>ForceMode.Force 默认方式，以钢体的质量计算以每帧间隔时间为单位计算动量。</li><li>ForceMode.Impulse 此种方式采用瞬间力作用方式</li></ul><h3 id="ParticleSystem-Play-ParticleSystem-Stop"><a href="#ParticleSystem-Play-ParticleSystem-Stop" class="headerlink" title="ParticleSystem.Play / ParticleSystem.Stop"></a>ParticleSystem.Play <a href="http://particlesystem.Play/" target="_blank" rel="noopener">/</a> ParticleSystem.Stop</h3><p>启动/停止 粒子特效</p><h3 id="AudioSource-PlayOneShot"><a href="#AudioSource-PlayOneShot" class="headerlink" title="AudioSource.PlayOneShot"></a>AudioSource.PlayOneShot</h3><p>播放AudioClip</p><div class="hljs"><pre><code class="hljs csharp">PlayOneShot(AudioClip clip, <span class="hljs-keyword">float</span> volumeScale = <span class="hljs-number">1.0F</span>);</code></pre></div><h3 id="Animator-Set…"><a href="#Animator-Set…" class="headerlink" title="Animator.Set…"></a>Animator.Set…</h3><h3 id="MoveLeft"><a href="#MoveLeft" class="headerlink" title="MoveLeft"></a>MoveLeft</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveLeft</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> leftBound;<span class="hljs-comment">//边界</span>    <span class="hljs-keyword">private</span> PlayerController playerController;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-comment">//playerController = GameObject.Find("Player").GetComponent<PlayerController>();</span>        playerController = FindObjectOfType<PlayerController>();<span class="hljs-comment">//使用PlayerController对象</span>    }        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (!playerController.isGameOver)        {            transform.Translate(Vector3.left * speed * Time.deltaTime);<span class="hljs-comment">//场景地板向左移动</span>        }        <span class="hljs-keyword">if</span> (transform.position.x < leftBound && gameObject.CompareTag(<span class="hljs-string">"Obstacle"</span>))        {            Destroy(gameObject);<span class="hljs-comment">//删除越界的障碍物</span>        }    }}</code></pre></div><h3 id="SpawnManager"><a href="#SpawnManager" class="headerlink" title="SpawnManager"></a>SpawnManager</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpawnManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> PlayerController playerController;    <span class="hljs-keyword">public</span> GameObject obstraclePrefab;    <span class="hljs-keyword">private</span> Vector3 spawnPos = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> startDelay, repeatRate;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        InvokeRepeating(<span class="hljs-keyword">nameof</span>(SpawnObstacle),startDelay,repeatRate);        playerController = FindObjectOfType<PlayerController>();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnObstacle</span>(<span class="hljs-params"></span>)</span> {        <span class="hljs-keyword">if</span> (!playerController.isGameOver)        {<span class="hljs-comment">//生成障碍物</span>            Instantiate(obstraclePrefab, spawnPos, Quaternion.identity);        }    }}</code></pre></div><h3 id="Quaternion-identity和transform-rotation区别"><a href="#Quaternion-identity和transform-rotation区别" class="headerlink" title="Quaternion.identity和transform.rotation区别"></a>Quaternion.identity和transform.rotation区别</h3><ul><li>Quaternion.identity就是指Quaternion(0,0,0,0),就是每旋转前的初始角度,是一个确切的值</li><li>transform.rotation是指本物体的角度,值是不确定的,比如可以这么设置transform.rotation = Quaternion.identity;</li><li>一个是值类型,一个是属性变量</li></ul><h3 id="BgRepeat"><a href="#BgRepeat" class="headerlink" title="BgRepeat"></a>BgRepeat</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BgRepeat</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Vector3 startPos;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> repeatWidth;    <span class="hljs-comment">//背景循环滚动</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        startPos = transform.position;        repeatWidth = GetComponent<BoxCollider>().size.x / <span class="hljs-number">2</span>;        <span class="hljs-comment">//通过boxcollider获得一半的长度</span>    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (transform.position.x < startPos.x - repeatWidth)        {            transform.position = startPos;        }    }}</code></pre></div><p>效果图：</p><ul><li>（转成了gif所以很卡）<br><img src="/img/2020-7-16.gif" srcset="/img/loading.gif" alt="效果图"></li></ul><hr><h1 id="Day-5-练习题"><a href="#Day-5-练习题" class="headerlink" title="Day 5 练习题"></a>Day 5 练习题</h1><p>今天的课和之前一样，属于对现有场景进行修补的，没什么难度就不写了，分享一下10道官方题。</p><!-- more --><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><img src="/img/cst1.png" srcset="/img/loading.gif" alt="测试题1"></p><h3 id="答案：B"><a href="#答案：B" class="headerlink" title="答案：B"></a>答案：B</h3><h3 id="解析：如果不设置权限的话，默认为private。"><a href="#解析：如果不设置权限的话，默认为private。" class="headerlink" title="解析：如果不设置权限的话，默认为private。"></a>解析：如果不设置权限的话，默认为private。</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="/img/cst2.png" srcset="/img/loading.gif" alt="测试题2"></p><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h3 id="解析：一眼看出答案。"><a href="#解析：一眼看出答案。" class="headerlink" title="解析：一眼看出答案。"></a>解析：一眼看出答案。</h3><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><img src="/img/cst3.png" srcset="/img/loading.gif" alt="测试题3"></p><h3 id="答案：A"><a href="#答案：A" class="headerlink" title="答案：A"></a>答案：A</h3><h3 id="解析：只有A选项让Speed-f-gt-0-25，触发动画。"><a href="#解析：只有A选项让Speed-f-gt-0-25，触发动画。" class="headerlink" title="解析：只有A选项让Speed_f>0.25，触发动画。"></a>解析：只有A选项让Speed_f>0.25，触发动画。</h3><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p><img src="/img/cst4.png" srcset="/img/loading.gif" alt="测试题4"></p><h3 id="答案：A-1"><a href="#答案：A-1" class="headerlink" title="答案：A"></a>答案：A</h3><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><img src="/img/cst5.png" srcset="/img/loading.gif" alt="测试题5"></p><h3 id="答案：D"><a href="#答案：D" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><img src="/img/cst6.png" srcset="/img/loading.gif" alt="测试题6"></p><h3 id="答案：C-1"><a href="#答案：C-1" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p><img src="/img/cst7.png" srcset="/img/loading.gif" alt="测试题7"></p><h3 id="答案：B-1"><a href="#答案：B-1" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p><img src="/img/cst8.png" srcset="/img/loading.gif" alt="测试题8"></p><h3 id="答案：D-1"><a href="#答案：D-1" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p><img src="/img/cst9.png" srcset="/img/loading.gif" alt="测试题9"></p><h3 id="答案：B-2"><a href="#答案：B-2" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><img src="/img/cst10.png" srcset="/img/loading.gif" alt="测试题10"></p><h3 id="答案：A-2"><a href="#答案：A-2" class="headerlink" title="答案：A"></a>答案：A</h3><hr><h1 id="Day-6-滚动小球儿"><a href="#Day-6-滚动小球儿" class="headerlink" title="Day 6 滚动小球儿"></a>Day 6 滚动小球儿</h1><p> 一个小球游戏，十分有趣。</p><!-- more --><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>操控一个小球通过 <code>WS</code> 来控前后，通过 <code>AD</code> 来控制镜头（左右）将敌人撞到台下</li><li>可以吃增益Buff，来使碰到自身的敌人被弹开</li><li>会不断的刷新敌人和增益物品，前提为前一波的敌人死亡，往后每一批的敌人都会比之前的多一个敌人</li></ul><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/img/unit4.gif" srcset="/img/loading.gif" alt="效果图"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>用空物体创建锚点</li><li>Input.GetButton(“String”) 获得bool值</li></ul><h2 id="SpwanManager"><a href="#SpwanManager" class="headerlink" title="SpwanManager"></a>SpwanManager</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpwanManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> GameObject enemy;    <span class="hljs-keyword">public</span> GameObject powerUp;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> spawnRange;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> enemyCount;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> waveNum = <span class="hljs-number">1</span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        enemyCount = FindObjectsOfType<Enemy>().Length;        <span class="hljs-keyword">if</span> (enemyCount == <span class="hljs-number">0</span>)        {            SpawnEnemy(waveNum);            waveNum++;            Instantiate(powerUp, RandomPos(), powerUp.transform.rotation);        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> Vector3 <span class="hljs-title">RandomPos</span>(<span class="hljs-params"></span>)</span> {        <span class="hljs-keyword">float</span> spawnPosX = Random.Range(-spawnRange,spawnRange);        <span class="hljs-keyword">float</span> spawnPosZ = Random.Range(-spawnRange, spawnRange);        Vector3 randomPos = <span class="hljs-keyword">new</span> Vector3(spawnPosX, <span class="hljs-number">0</span>, spawnPosZ);        <span class="hljs-keyword">return</span> randomPos;    }<span class="hljs-comment">//提供一个随机的向量，以供敌人的随机生成。</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpawnEnemy</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> wave</span>)</span> {         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < wave; i++)        {            Instantiate(Enemy, RandomPos(), Quaternion.identity);        }    }}</code></pre></div><h3 id="FindObjectsOfType-Length"><a href="#FindObjectsOfType-Length" class="headerlink" title="FindObjectsOfType().Length"></a>FindObjectsOfType<enemy>().Length</enemy></h3><p>遍历场景中的对象，寻找Enemy类型，获得总共有多少个Enemy的数值</p><h2 id="PlayerController-1"><a href="#PlayerController-1" class="headerlink" title="PlayerController"></a>PlayerController</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEditor;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> UnityEngine.UIElements;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    <span class="hljs-keyword">private</span> GameObject focalPoint;<span class="hljs-comment">//获得中心点，以保证小球移动方向</span>    <span class="hljs-keyword">public</span> GameObject Ring;<span class="hljs-comment">//使获得buff可视化</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isPowerup;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> powerStrength;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        rb = GetComponent<Rigidbody>();        focalPoint = GameObject.Find(<span class="hljs-string">"Focal Point"</span>);    }        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">float</span> forwardInput = Input.GetAxis(<span class="hljs-string">"Vertical"</span>);        rb.AddForce(focalPoint.transform.forward * speed * forwardInput);<span class="hljs-comment">//通过判断buff的激活状态，使得可视化现实</span>        Ring.SetActive(isPowerup);<span class="hljs-comment">//通过判断buff的激活状态，来调整可视化buff与Player的绑定</span>        <span class="hljs-keyword">if</span> (isPowerup)        {            Ring.transform.position = transform.position + <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">-0.4f</span>, <span class="hljs-number">0</span>);        }    }    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>    {<span class="hljs-comment">//获得增益</span>        <span class="hljs-keyword">if</span> (other.CompareTag(<span class="hljs-string">"PowerUp"</span>)) {            isPowerup = <span class="hljs-literal">true</span>;            <span class="hljs-comment">//Ring.SetActive(true);</span>            Destroy(other.gameObject);            StartCoroutine(PowerUpCountDown());        }    }    <span class="hljs-function">IEnumerator <span class="hljs-title">PowerUpCountDown</span>(<span class="hljs-params"></span>)</span>    {<span class="hljs-comment">//协同处理，用来给获得的增益来计时</span>        <span class="hljs-function"><span class="hljs-keyword">yield</span> return new <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;        isPowerup = <span class="hljs-literal">false</span>;        <span class="hljs-comment">//Ring.SetActive(false);</span>    }    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>    {<span class="hljs-comment">//设置buff的功能</span>         <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">"Enemy"</span>) && isPowerup) {            Rigidbody enemyRb = collision.gameObject.GetComponent<Rigidbody>();            Vector3 dirFromPlayer = collision.transform.position - transform.position;            enemyRb.AddForce(dirFromPlayer * powerStrength, ForceMode.Impulse);         }    }}</code></pre></div><h2 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h2><p>协同处理</p><ul><li>所有IEnumerator类型函数必须使用”StartCoroutine”这个函数触发，不能单独使用</li></ul><div class="hljs"><pre><code class="hljs csharp">StartCoroutine(DoSomeThingInDelay());</code></pre></div><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>延迟加载，在C#中，yield不能单独使用，需要配合return 如</p><ul><li>yield return 1; 等1帧</li><li>yield return WaitForSeconds(1 );等一秒</li></ul><h2 id="Enemy"><a href="#Enemy" class="headerlink" title="Enemy"></a>Enemy</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    <span class="hljs-keyword">private</span> GameObject player;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        rb = GetComponent<Rigidbody>();        player = FindObjectOfType<PlayerController>().gameObject;<span class="hljs-comment">//返回的类型变量，所以后面加.gameobject</span>    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {<span class="hljs-comment">//使得enemy向player移动</span>        Vector3 playerDir = (player.transform.position - transform.position).normalized;<span class="hljs-comment">//单位化，无论他们是多少，都判定为1</span>        rb.AddForce(playerDir * speed);        <span class="hljs-keyword">if</span> (transform.position.y < <span class="hljs-number">-10</span>)        {            Destroy(gameObject);        }    }}</code></pre></div><h2 id="设置镜头移动"><a href="#设置镜头移动" class="headerlink" title="设置镜头移动"></a>设置镜头移动</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RotateCamera</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> rotationSpeed;<span class="hljs-comment">//镜头旋转</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">float</span> horizontalInput = Input.GetAxis(<span class="hljs-string">"Horizontal"</span>);        transform.Rotate(Vector3.up, horizontalInput * rotationSpeed * Time.deltaTime);    }}</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Day-4-跑酷小游戏&quot;&gt;&lt;a href=&quot;#Day-4-跑酷小游戏&quot; class=&quot;headerlink&quot; title=&quot;Day 4 跑酷小游戏&quot;&gt;&lt;/a&gt;Day 4 跑酷小游戏&lt;/h1&gt;&lt;p&gt;一个跑酷的小游戏和滚动小球儿，感觉还挺有趣的。&lt;/p&gt;
&lt;p&gt;内附10道测试题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="暑期学习" scheme="http://yancc.cc/tags/暑期学习/"/>
    
    <category term="Unity" scheme="http://yancc.cc/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Chrome下载文件变成html的解决方案</title>
    <link href="http://yancc.cc/2020/07/14/Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%98%E6%88%90html%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yancc.cc/2020/07/14/Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%98%E6%88%90html%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-07-14T04:06:47.000Z</published>
    <updated>2021-01-07T09:35:46.889Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现windows那台电脑上的Chrome无论下载什么都会变成xxx.html，即便是另存为也是一样的情况。</p><a id="more"></a><p>解决方案：按住<code>Alt</code>键位再点击下载就可以了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近发现windows那台电脑上的Chrome无论下载什么都会变成xxx.html，即便是另存为也是一样的情况。&lt;/p&gt;</summary>
    
    
    
    
    <category term="问题解决" scheme="http://yancc.cc/tags/问题解决/"/>
    
    <category term="小技巧" scheme="http://yancc.cc/tags/小技巧/"/>
    
  </entry>
  
  <entry>
    <title>Unity官方课程学习记录 2020.07.13-15</title>
    <link href="http://yancc.cc/2020/07/13/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.13-15/"/>
    <id>http://yancc.cc/2020/07/13/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.13-15/</id>
    <published>2020-07-13T15:55:15.000Z</published>
    <updated>2021-01-07T06:56:54.287Z</updated>
    
    <content type="html"><![CDATA[<p>找了找资源，发现Unity中文社区的内容也在蓬勃发展，于是打算双线操作，一边学习C#的进阶特性，一遍开始跟着官方的课搞一搞，本篇是关于镜头绑定以及移动控制，当然，还会有一点小tips。</p><a id="more"></a><h1 id="Unit-1-镜头绑定和角色控制"><a href="#Unit-1-镜头绑定和角色控制" class="headerlink" title="Unit 1  镜头绑定和角色控制"></a>Unit 1  镜头绑定和角色控制</h1><h2 id="一点微小的知识"><a href="#一点微小的知识" class="headerlink" title="一点微小的知识"></a>一点微小的知识</h2><ul><li>按 <code>CTRL</code> 可以对transform进行微调，缺省值为0.25，可以再Grid and Snap中设置</li><li>按 <code>鼠标右键</code> 使用 <code>WASD</code> 可以进行视角移动，很方便</li><li>在 <code>Preferences</code> 中，Colors → Playmode tint，可以设置游戏在unity运行中系统页面的变化，已达到提高辨识度的效果</li></ul><h2 id="镜头绑定"><a href="#镜头绑定" class="headerlink" title="镜头绑定"></a>镜头绑定</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> GameObject player;    <span class="hljs-keyword">private</span> Vector3 offset = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-10</span>);    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {            }        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>) <span class="hljs-comment">//每一帧都会被调用</span>        }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>(<span class="hljs-params"></span>)</span>    {        transform.position = player.transform.position + offset;    }}</code></pre></div><h2 id="Update-与-lateUpdate-的区别"><a href="#Update-与-lateUpdate-的区别" class="headerlink" title="Update() 与 lateUpdate()的区别"></a>Update() 与 lateUpdate()的区别</h2><ul><li>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。<ul><li><del>人话：lateUpadate晚于Update执行</del></li><li>即使在统一帧中执行，但是Update会先执行，lateUpdate后执行</li></ul></li><li>通过这个可以解决相机绑定gameObject造成的抖动效果</li></ul><h2 id="Player移动"><a href="#Player移动" class="headerlink" title="Player移动"></a>Player移动</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span>{       <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed; <span class="hljs-comment">//private 变量在unity中不可见</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> turnSpeed;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> verticalInput;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> horizontalInput;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {            }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        verticalInput = Input.GetAxis(<span class="hljs-string">"Vertical"</span>);<span class="hljs-comment">//-1 1</span>        horizontalInput = Input.GetAxis(<span class="hljs-string">"Horizontal"</span>);        <span class="hljs-comment">//Vector3.forward 决定方向 Time.deltaTime 决定在不同设备速度一样</span>        transform.Translate(Vector3.forward * Time.deltaTime * speed * verticalInput);        transform.Rotate(Vector3.up,Time.deltaTime * turnSpeed * horizontalInput);<span class="hljs-comment">//0 1 0 </span>    }}</code></pre></div><h2 id="获得输入的方法——以“前后，左右”为例"><a href="#获得输入的方法——以“前后，左右”为例" class="headerlink" title="获得输入的方法——以“前后，左右”为例"></a>获得输入的方法——以“前后，左右”为例</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li>通过在 <strong>Project Settings</strong> 中的 <strong>Input Manager</strong> 可以获取每个输入的值，在脚本里就可以通过Input.GetAxis(“String”)来获取。</li></ul><h3 id="Horizontal"><a href="#Horizontal" class="headerlink" title="Horizontal"></a>Horizontal</h3><ul><li>在input中决定了方向，可以通过Input.GetAxis(“Horizontal”)获取后，用transform.Rotate()来更改方向。</li><li>值为0 1 0，以float方式存储。</li></ul><h3 id="Vertical"><a href="#Vertical" class="headerlink" title="Vertical"></a>Vertical</h3><ul><li>在input中决定了前进or后退，可以通过Input.GetAxis(“Vertical”)获取后，用transform.Translate()来更改前后。</li><li>值为-1 1，以float方式存储。</li></ul><h3 id="Time-deltaTime"><a href="#Time-deltaTime" class="headerlink" title="Time.deltaTime"></a>Time.deltaTime</h3><p>留坑，第二天再写</p><h3 id="Vertical3"><a href="#Vertical3" class="headerlink" title="Vertical3"></a>Vertical3</h3><p>留坑</p><h1 id="Unit-2-基本的游戏"><a href="#Unit-2-基本的游戏" class="headerlink" title="Unit 2 基本的游戏"></a>Unit 2 基本的游戏</h1><h2 id="一点微小的知识-1"><a href="#一点微小的知识-1" class="headerlink" title="一点微小的知识"></a>一点微小的知识</h2><ul><li>通过Gizmos调整摄像机在Scene中的范围。</li><li>在Scene中，使用 <code>鼠标右键</code> + <code>滚轮</code> 可以调整用WASD控制试图的时候的移动速度。</li><li>在调整三维向量时候，为了避免搞晕自己，可以切换到各个轴视角调整，按住 <code>Ctrl</code> 后可以进行等边调整。</li><li>拖拽预制体时尽量在Hierarchy面板中，如果在Scene中很可能是悬空的。</li></ul><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><p>游戏中<code>自动生成</code>朝向Player奔跑的“动物”，通过<code>左右移动</code>和<code>空格</code>发射食物，使其消失。</p><h2 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerControllor</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">40f</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> horizontalInput;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> xRange;    <span class="hljs-keyword">public</span> GameObject pizzaPrefeb;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        horizontalInput = Input.GetAxisRaw(<span class="hljs-string">"Horizontal"</span>);        transform.Translate(Vector3.right * horizontalInput * Time.deltaTime * speed);<span class="hljs-comment">//设定边界 原理：通过给判断人物transform中position的x大于边界，如果成立就把边界的值赋给其，已达到边界限制的作用。</span>        <span class="hljs-keyword">if</span> (transform.position.x > xRange)        {            transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        }        <span class="hljs-keyword">if</span> (transform.position.x < -xRange)         {            transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        }        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space))         {            Instantiate(pizzaPrefeb, transform.position, pizzaPrefeb.transform.rotation);        }    }}</code></pre></div><h3 id="GetAxisRaw"><a href="#GetAxisRaw" class="headerlink" title="GetAxisRaw"></a>GetAxisRaw</h3><ul><li>与GetAxis不同的是，GetAxisRaw是从键盘获取 0，-1，0三个数，而GetAxis是获取-1，1之间的一个数，类似开车或者刹车。</li></ul><h3 id="Input-GetKeyDown"><a href="#Input-GetKeyDown" class="headerlink" title="Input.GetKeyDown"></a>Input.GetKeyDown</h3><ul><li>当用户按下指定名称的按键时的那一帧返回true</li><li>要在Update方法中调用这个方法，此后每一帧重置状态时，它将不会返回true除非用户释放这个按钮然后重新按下它</li></ul><h2 id="MoveForward"><a href="#MoveForward" class="headerlink" title="MoveForward"></a>MoveForward</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveForward</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">40f</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        transform.Translate(Vector3.forward * speed * Time.deltaTime); <span class="hljs-comment">//forward .z</span>        <span class="hljs-comment">//设置上下的边界</span>        <span class="hljs-keyword">if</span> (transform.position.z < <span class="hljs-number">-107f</span> )        {            Destroy(gameObject);        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>    {        Destroy(collision.gameObject);        Destroy(gameObject);    }}</code></pre></div><h2 id="OnCollisionEnter"><a href="#OnCollisionEnter" class="headerlink" title="OnCollisionEnter"></a>OnCollisionEnter</h2><ul><li>OncollisionEnter方法要求碰撞的发起方必须有钢体，只要碰撞双方一个有钢体，则二者都会触发OncollisionEnter方法。所以钢体是判断是否碰撞的标志。</li><li>collision.gameObject为被碰撞对象。</li></ul><h3 id="有钢体的情况"><a href="#有钢体的情况" class="headerlink" title="有钢体的情况"></a>有钢体的情况</h3><p>A对象与B对象相撞后，无论是谁先撞上的谁，都可以触发OncollisionEnter方法。</p><h3 id="没有钢体的情况"><a href="#没有钢体的情况" class="headerlink" title="没有钢体的情况"></a>没有钢体的情况</h3><p>A有钢体，B没有，A去撞B，则AB都会触发OncollisionEnter方法。</p><p>A有钢体，B没有，B来撞A，则AB都不会触发OncollisionEnter方法。</p><h3 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h3><ul><li>Destroy(gameObject)，用来摧毁一个游戏对象。</li></ul><h2 id="SpawnManager"><a href="#SpawnManager" class="headerlink" title="SpawnManager"></a>SpawnManager</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> System.Security.Cryptography;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpawnManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> GameObject[] animPrefab;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> xRange;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        InvokeRepeating(<span class="hljs-keyword">nameof</span>(SpawnAnimal),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpawnAnimal</span>(<span class="hljs-params"></span>)</span>     {        index = Random.Range(<span class="hljs-number">0</span>, animPrefab.Length);        <span class="hljs-keyword">float</span> xPosition = Random.Range(xRange, -xRange);        Instantiate(animPrefab[index], <span class="hljs-keyword">new</span> Vector3(xPosition, <span class="hljs-number">0f</span>, <span class="hljs-number">30f</span>), animPrefab[index].transform.rotation);    }}</code></pre></div><h3 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke"></a>Invoke</h3><div class="hljs"><pre><code class="hljs csharp">Invoke(methodName: <span class="hljs-keyword">string</span>, time: <span class="hljs-keyword">float</span>): <span class="hljs-keyword">void</span>;methodName:方法名time:多少秒后执行</code></pre></div><h3 id="InvokeRepeating"><a href="#InvokeRepeating" class="headerlink" title="InvokeRepeating"></a>InvokeRepeating</h3><div class="hljs"><pre><code class="hljs csharp">InvokeRepeating(methodName: <span class="hljs-keyword">string</span>, time: <span class="hljs-keyword">float</span>, repeatRate: <span class="hljs-keyword">float</span>): <span class="hljs-keyword">void</span>;methodName:方法名time:多少秒后执行repeatRate：重复执行间隔</code></pre></div><h3 id="Instantiate"><a href="#Instantiate" class="headerlink" title="Instantiate"></a>Instantiate</h3><ul><li>Instantiate(gameObject)，创建游戏对象。</li></ul><h1 id="Unit-3-一些微小的思考"><a href="#Unit-3-一些微小的思考" class="headerlink" title="Unit 3 一些微小的思考"></a>Unit 3 一些微小的思考</h1><h2 id="游戏实现-1"><a href="#游戏实现-1" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>人物通过空格召唤一匹马，用马来接球</li><li>如果接到球，马会消失，没接到，游戏结束</li></ul><p>太简单了就没写如何实现，写了一些思考。</p><h2 id="Prefab-Variant-与-Original-Prefab"><a href="#Prefab-Variant-与-Original-Prefab" class="headerlink" title="Prefab Variant 与 Original Prefab"></a>Prefab Variant 与 Original Prefab</h2><p>prefab是通过一个original的prefab，可以通过很多便利，比如我们创建一个没有任何属性的“人”的original prefab，这里就可以创建很多变体</p><ul><li>人的国籍</li><li>人的语言，声音等等</li></ul><p>变体的prefab会继承original的全部属性，可以通过复写改掉prefab的属性，变体可以基于任何的prefab，很像代码中的继承。</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>因为普通的Random的随机数是通过时间生成的，短时间内多次调用会造成生成的随机数一直，如果我们需要改变的话可以通过</p><ul><li><p>每生成完随机数后让线程睡眠1ms</p><ul><li>thread.sleep(1);</li></ul></li><li><p>RNGCryptoServiceProvider(); 产生相对真的随机数</p><ul><li>使用前提：</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Security.Cryptography;<span class="hljs-keyword">using</span> System;</code></pre></div><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">byte</span>[] randomBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];RNGCryptoServiceProvider rngCrypto = <span class="hljs-keyword">new</span> RNGCryptoServiceProvider();rangCrypo.GetBytes(randomBytes);<span class="hljs-keyword">int</span> rngNum = BitConerter.ToInt32(randomBytes,<span class="hljs-number">0</span>)<span class="hljs-comment">//计算量很大，如果想要0-100范围的为rngNum = rngNum % 100</span></code></pre></div></li></ul><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>通过设置Tag来达到在脚本中识别对象的问题，如果调用的话可以使用:</p><ul><li>gameObject.CompareTag(“String”)</li></ul><h3 id="CompareTag比gameObject-tag的优势"><a href="#CompareTag比gameObject-tag的优势" class="headerlink" title="CompareTag比gameObject.tag的优势"></a>CompareTag比gameObject.tag的优势</h3><p>由于gameObject.tag中的tag是属性，要先花时间调用一次getter来获得字符串，而CompareTag只需要调用一次内部方法，节省性能总是好的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;找了找资源，发现Unity中文社区的内容也在蓬勃发展，于是打算双线操作，一边学习C#的进阶特性，一遍开始跟着官方的课搞一搞，本篇是关于镜头绑定以及移动控制，当然，还会有一点小tips。&lt;/p&gt;</summary>
    
    
    
    
    <category term="暑期学习" scheme="http://yancc.cc/tags/暑期学习/"/>
    
    <category term="Unity" scheme="http://yancc.cc/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity笔记汇总 2020.07.11-13</title>
    <link href="http://yancc.cc/2020/07/11/%E6%9A%91%E6%9C%9FU3D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9520.07.11-13/"/>
    <id>http://yancc.cc/2020/07/11/%E6%9A%91%E6%9C%9FU3D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9520.07.11-13/</id>
    <published>2020-07-11T12:00:04.000Z</published>
    <updated>2021-01-07T06:57:24.133Z</updated>
    
    <content type="html"><![CDATA[<p>拿暑期的时间系统的学一下U3D和C#，之前都是用什么学什么，知识点都散。之前的swift复习就鸽了，因为整理到后面发现完全没必要写= =#，最后考的也挺好。</p><a id="more"></a><p>学习资料是看的千锋初级，讲了一段u3d基础功能后就开始C#的进阶课程了。</p><blockquote><ul><li>链接: <a href="https://pan.baidu.com/s/1lZn1hqRCFF7rVGib0G2pgg" target="_blank" rel="noopener">https://pan.baidu.com/s/1lZn1hqRCFF7rVGib0G2pgg</a> </li><li>提取码: kq6z</li></ul></blockquote><h1 id="2020-07-11"><a href="#2020-07-11" class="headerlink" title="2020.07.11"></a>2020.07.11</h1><p>以下为本日所学：</p><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><p><code>ducplicate</code>  复制 和 <code>copy</code>  拷贝 不一样</p><p><code>Edit</code> </p><p><code>Preference</code> 偏好设置</p><p><code>Assests</code> 资源</p><p><code>show in explorer</code> 在文件管理器这打开</p><p><code>import Package</code> 导入资源包</p><p><code>GameObject</code> 游戏对象</p><p><code>Component</code> 组件</p><p><code>Window</code>  unity 面板窗口</p><p><code>Help</code> </p><h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><p><code>Layout</code> 布局方式 </p><p><code>Revert Factory</code>  恢复出厂设置</p><p><code>Project</code> 项目面板——管理一个项目中用到的所有资源文件</p><p><code>Scene</code> 场景面板——用来编辑场景，列出场景中所有的对象</p><p><code>Game</code> 游戏面板——玩家看到的面板，由场景中的摄像机拍摄到的 </p><p><code>Hierarchy</code> 层级面板——管理所有中的游戏对象，将所有的游戏对象以层级的形式列举出来</p><p><code>Inspector</code> 检视面板——显示一个游戏对象身上的组件；显示组件中的属性</p><h2 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h2><p><code>坐标系</code>  unity：左手坐标系，数学：右手坐标系</p><h2 id="场景中的操作"><a href="#场景中的操作" class="headerlink" title="场景中的操作"></a>场景中的操作</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><code>旋转</code>  alt+左键 or 右键</p><p><code>右上角的锁</code>  锁定旋转</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><code>缩放</code>  鼠标滚轮</p><h2 id="快速的在场景中找到指定的游戏对象"><a href="#快速的在场景中找到指定的游戏对象" class="headerlink" title="快速的在场景中找到指定的游戏对象"></a>快速的在场景中找到指定的游戏对象</h2><ul><li>在Hierarchy中找到对象，双击</li><li>在Hierarchy中单机选中，在场景中按F</li></ul><h2 id="拖动场景"><a href="#拖动场景" class="headerlink" title="拖动场景"></a>拖动场景</h2><p><code>拖动</code> 按住鼠标中键；Q</p><h2 id="左上角的工具——快捷键依次为QWERT"><a href="#左上角的工具——快捷键依次为QWERT" class="headerlink" title="左上角的工具——快捷键依次为QWERT"></a>左上角的工具——快捷键依次为QWERT</h2><p><code>手</code> 移动</p><p><code>Move tool</code> 移动物体 影响Transform.Position</p><p><code>Rotate Tool</code> 旋转 影响Transform.Rotation</p><p><code>Scale Tool</code> 缩放 影响Transform.Scale</p><p><code>Rect Tool</code> 缩放</p><h2 id="切换中心点"><a href="#切换中心点" class="headerlink" title="切换中心点"></a>切换中心点</h2><ul><li>Pivot 选中的游戏对象中心点</li><li>Center 所有选中的对象的计算出来的中心点</li><li>快捷键位：Z</li></ul><h2 id="切换坐标系"><a href="#切换坐标系" class="headerlink" title="切换坐标系"></a>切换坐标系</h2><ul><li>Global 采用世界坐标——东南西北</li><li>Local 采用自身坐标——前后左右</li><li>快捷键：X</li></ul><h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><h2 id="父子物体关系"><a href="#父子物体关系" class="headerlink" title="父子物体关系"></a>父子物体关系</h2><ul><li>一个游戏对象，只能有一个父物体</li><li>一个游戏对象，可以有无数个子物体</li><li>子物体的操作不会对父物体产生影响，反之则会</li><li>子物体的位置、旋转、缩放都是相对于父物体的</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>具有一定功能的集合</li><li>如果希望游戏对象具有什么功能，只需要给这个游戏对象添加相应的组件即可</li></ul><h3 id="Mesh-Filter"><a href="#Mesh-Filter" class="headerlink" title="Mesh Filter"></a>Mesh Filter</h3><ul><li>网格过滤器，决定了一个对象的形状</li></ul><h3 id="Mesh-Renderer"><a href="#Mesh-Renderer" class="headerlink" title="Mesh Renderer"></a>Mesh Renderer</h3><ul><li>决定了一个游戏对象的外观展示</li></ul><h2 id="材质-Material"><a href="#材质-Material" class="headerlink" title="材质 Material"></a>材质 Material</h2><ul><li>决定一个对象的外观</li></ul><hr><h1 id="2020-07-12"><a href="#2020-07-12" class="headerlink" title="2020.07.12"></a>2020.07.12</h1><p>（题外话，早点起床会觉得一天特别充实！）</p><p>接上篇，今日学习为：</p><!-- more --><h2 id="预制体"><a href="#预制体" class="headerlink" title="预制体"></a>预制体</h2><ul><li>将某个游戏对象以文件的形式存储起来</li><li>作用：用来批量管理游戏对象；修改预制体的缩放，会对所有的游戏对象都产生影响；给预制体加上组件，所有的对象都会有添加组件</li></ul><p><code>Select</code> 快速找到这个对象对应的预制体</p><p><strong>Overrides</strong></p><p><code>Revert</code> 将游戏对象的组件及属性还原为预制体中的定义</p><p><code>Apply</code> 将对象的属性应用到预制体</p><h2 id="资源包"><a href="#资源包" class="headerlink" title="资源包"></a>资源包</h2><ul><li>可以把项目中的资源打包导出</li><li>如何打包Project下 → Export packages</li><li>如何导入Project下 → Import packages；拖进project；直接双击资源</li><li>标准资源包：Standard Assest 路径Unity/Editor/Standard</li></ul><h2 id="地形-Terrain"><a href="#地形-Terrain" class="headerlink" title="地形 Terrain"></a>地形 Terrain</h2><p>组件</p><ul><li>Raise/Lower Terrain——升高or下降的地形<ul><li>Brushes 笔刷</li><li><code>Opacity</code> 笔刷的硬度，决定一次抬高的高度</li><li>按住 <code>Shift</code> 可以降低，但最低是和terrain平行</li></ul></li><li>Paint Height——设置一个高度，然后将高于这个高度的部分刷低，将低于的这个高度的部分刷高<ul><li>Hold on <code>shift</code> 可以从已有高度选取高度</li><li>Flatten 将设定的高度应用给整个地形</li></ul></li><li>Smooth Height——平滑地形，使棱角分明的地方变得圆润平滑</li><li>Paint Texture——绘制地面纹理<ul><li>第一个添加的纹理会作用给全部的地形</li></ul></li><li>Place Trees<ul><li>Density 密度</li></ul></li><li>Paint Detail</li><li>Settings</li></ul><h2 id="钢体-Rigidbody"><a href="#钢体-Rigidbody" class="headerlink" title="钢体 Rigidbody"></a>钢体 Rigidbody</h2><p>模拟现实中的物理效果</p><ul><li>Mass 质量</li><li>Drag  拉力——运动方向的阻力</li><li>Angular Drag 旋转的拉力</li><li>Use Gravity 使用重力</li><li>Is Kinematic 开启运动学</li><li>Interpolate 插值</li><li>Collision Detection 碰撞检测</li><li>Constraints 约束<ul><li>Freeze Position</li><li>Freeze Potation</li></ul></li></ul><h2 id="碰撞体组件-Collider"><a href="#碰撞体组件-Collider" class="headerlink" title="碰撞体组件 Collider"></a>碰撞体组件 Collider</h2><p>两个物体发生碰撞，实际上产生的是两个碰撞体</p><h2 id="物理材质-Physics-Material"><a href="#物理材质-Physics-Material" class="headerlink" title="物理材质 Physics Material"></a>物理材质 Physics Material</h2><p>如果没有设置物理材质，摩擦力为无限大，弹力为0</p><ul><li>Dynamic Fricction 动态摩擦力</li><li>Static Friction 静态摩擦力 没有相对位移时候的摩擦力</li><li>Bounciness 弹力</li><li>Friction Combine 阻隔摩擦力</li><li>Bounce Combine 弹力摩擦力</li></ul><hr><h1 id="2020-07-13"><a href="#2020-07-13" class="headerlink" title="2020.07.13"></a>2020.07.13</h1><p>基础的unity功能看完了，明天开始要开始C#的进阶了。</p><!-- more --><h2 id="fbx-模型文件"><a href="#fbx-模型文件" class="headerlink" title=".fbx 模型文件"></a>.fbx 模型文件</h2><ul><li>模型文件最好Z轴指向的是前方</li></ul><h2 id="人物控制"><a href="#人物控制" class="headerlink" title="人物控制"></a>人物控制</h2><p>获取<em>水平轴</em>的偏移量，<em>垂直轴</em>的偏移量</p><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">float</span> horizontal = Input.GetAxis(<span class="hljs-string">"Horiziontal"</span>);<span class="hljs-keyword">float</span> vertical = Input.GetAxis(<span class="hljs-string">"Vertical"</span>);</code></pre></div><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-comment">// 判断是否有位移</span>        <span class="hljs-keyword">if</span> (direction != Vector3.zero)        {            <span class="hljs-comment">//将角色旋转至指定的方向</span>            transform.rotation = Quaternion.LookRotation(direction);            <span class="hljs-comment">//角色移动</span>            transform.Translate(Vector3.forward * <span class="hljs-number">1</span> * Time.deltaTime);        }</code></pre></div><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>具有大小和方向的，如果只有大小没有方向为标量</p><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-comment">//算出方向向量</span>Vector3 direction = <span class="hljs-keyword">new</span> Vector3(horizontal,<span class="hljs-number">0</span>,vertical);</code></pre></div><h1 id="back-to-C"><a href="#back-to-C" class="headerlink" title="back to C"></a>back to C</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul><li>十进制 逢十进一 数字由0~9来表示</li><li>二进制 逢二进一 数字由0~1来表示</li><li>八进制 逢八进一 数字由0~7来表示</li><li>十六进制 逢十六进一 数字由0<del>9 A</del>F 来表示</li></ul><ul><li>对于二进制来说，每进一位相当于乘2，对于十进制来说，每进一位相对于乘10，以此类推</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><ul><li>十进制与其他进制转换<ul><li>转其他进制 <code>辗转相除法</code> 用这个数字除想<em>要转换的进制</em>，再用商除进制，一直到商为0，结束，将每一步的余数倒着连起来</li><li>转十进制 用某位的数字，乘进制的位数-1次方</li></ul></li><li>二进制与八进制、十六进制的转换<ul><li>二进制与八进制 一个八进制位 == 三个二进制位</li><li>二进制与十六进制 一个十六进制位 == 四个二进制位</li></ul></li></ul><h2 id="常用单位转换"><a href="#常用单位转换" class="headerlink" title="常用单位转换"></a>常用单位转换</h2><ul><li>把每一个二进制位称作一个比特位 ⇒ bit</li><li>8bit ⇒ 1byte</li><li>1024byte ⇒ 1kb</li><li>1024kb ⇒ 1Mb</li><li>1024Mb ⇒ 1Gb</li><li>1024Gb ⇒ 1Tb</li><li>1024Tb ⇒ 1Pb</li></ul><h2 id="表示负数"><a href="#表示负数" class="headerlink" title="表示负数"></a>表示负数</h2><ul><li>把一个二进制最左边一位叫做最高位</li><li>如果需要表示负数，最高位为符号位，表示一个数字的大小，表示一个数字的正负性</li><li>如果最高位为1是负数，最高位为0为正数</li></ul><h2 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h2><ul><li>意义：所有数据在计算中存储和运算都是以补码的形式进行的</li><li>如果计算结果出现了溢出，则溢出的位全部舍去</li><li>由一个负数的补码求原码：对这个数字再求一次补码</li></ul><p>————————————————————————————</p><ul><li>原码：直接由其他进制计算过来的结果</li><li>反码：对原码符号位不变，其他位按位取反</li><li>补码：反码加1</li></ul><ul><li>以上规则仅限负数</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我以前居然写了这么多东西么= =# </p><p>2020.12.26</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;拿暑期的时间系统的学一下U3D和C#，之前都是用什么学什么，知识点都散。之前的swift复习就鸽了，因为整理到后面发现完全没必要写= =#，最后考的也挺好。&lt;/p&gt;</summary>
    
    
    
    
    <category term="暑期学习" scheme="http://yancc.cc/tags/暑期学习/"/>
    
    <category term="Unity" scheme="http://yancc.cc/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Swift基础语法</title>
    <link href="http://yancc.cc/2020/07/07/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yancc.cc/2020/07/07/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-07-07T07:29:26.000Z</published>
    <updated>2021-01-07T09:36:05.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="期末考试周"><a href="#期末考试周" class="headerlink" title="期末考试周"></a>期末考试周</h2><p>整理一下考试用到的Swift的基本语法，权当复习，一共会有四篇。本篇包含了注释，变量，常量，声明方式，数据类型，元祖，数组，字典。</p><a id="more"></a><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Swift有两种注释方式:<br><code>单行注释</code></p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-comment">// 我是单行注释</span></code></pre></div><p><code>多行注释</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-comment">/* 我是多行注释我是第二行*/</span></code></pre></div><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p>常量关键字为 <code>let</code> 常量不支持再进行赋值操作</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> <span class="hljs-type">PI</span> = <span class="hljs-number">3.1415926</span></code></pre></div><p>此时如果再给PI赋值，就会报错，这时候我们可以使用变量 <code>var</code></p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> wage = <span class="hljs-number">500</span>wage = <span class="hljs-number">700</span> <span class="hljs-comment">//将700再次赋值给wage，此时不会报错</span></code></pre></div><p>##声明方式：</p><p><code>隐式声明变量</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> name = value</code></pre></div><p><code>显示声明变量</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> name:type = value</code></pre></div><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>如果没有一个有效的命名，回过头来就很可能忘了这个变量或者常量是做什么使用的，所以这时候我们需要<strong>命名规范</strong></p><p><code>小驼峰命名</code> 除了首个单词,其他单词首字母大写,拼接起来</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> currentBuildingHeight = <span class="hljs-number">26</span></code></pre></div><p><code>大驼峰命名</code>或者叫<code>帕斯卡命名</code> 所有的单词都首字母大写</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> <span class="hljs-type">CurrentBuildingHeight</span> = <span class="hljs-number">26</span></code></pre></div><p><code>下划线命名法</code> 用下划线🔗 所有单词</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> current_building_height = <span class="hljs-number">26</span></code></pre></div><p><code>常量的命名方式</code><br>所有字母全部大些，并皆适用下划线连接单词，用尽可能的名称描述出常量的意义</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> <span class="hljs-type">BUILDING_LEVEL_HEIGHT</span> = <span class="hljs-number">3</span> <span class="hljs-comment">//使用常量 描述层高</span></code></pre></div><h2 id="打印方式"><a href="#打印方式" class="headerlink" title="打印方式"></a>打印方式</h2><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> <span class="hljs-type">BUILDING_LEVEL_HEIGHT</span> = <span class="hljs-number">3</span><span class="hljs-built_in">print</span>(<span class="hljs-type">BUILDING_LEVEL_HEIGHT</span>)<span class="hljs-built_in">debugPrint</span>(<span class="hljs-type">BUILDING_LEVEL_HEIGHT</span>)<span class="hljs-built_in">dump</span>(<span class="hljs-type">BUILDING_LEVEL_HEIGHT</span>)   <span class="hljs-comment">//dump在打印class的时候，会输出class中的全部属性</span></code></pre></div><h2 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h2><p><strong>1、布尔类型 Bool</strong></p><p><code>Bool类型</code>用来表示true和false，不过和c语言中<strong>不一样</strong>的是，swift对于bool的定义只有true和false，不能通过1和0来代替</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> bol:<span class="hljs-type">Bool</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//使用显式声明变量 bol，bol为true</span><span class="hljs-keyword">if</span>(bol){<span class="hljs-built_in">print</span>(<span class="hljs-string">"1"</span>) <span class="hljs-comment">//因为bol为true，所以执行语句print，输出1</span>}</code></pre></div><p><strong>2、整形 Int</strong></p><p><code>Int类型</code>用来表示整数</p><p>在32位系统中,Int类型代表了Int32,表示在内存中他存储的是32位长<br>在64位系统中,Int类型代表了Int64,表示在内存中他存储的是64位长</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> <span class="hljs-type">Interg</span>:<span class="hljs-type">Int</span> = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span><span class="hljs-keyword">var</span> <span class="hljs-type">Max</span>:<span class="hljs-type">Int64</span> = <span class="hljs-type">Int64</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">//显示64位内存中储存的Int64长度 9223372036854775807</span></code></pre></div><p>以Int8为例，Int8的最大值应该是128，但因为会有来表示的符号的最高位，所以最大值为127</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> num:<span class="hljs-type">Int8</span> = <span class="hljs-type">Int8</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">//127</span></code></pre></div><p>无符号Int8,没有位数限制，故为255</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> num:<span class="hljs-type">UInt8</span> = <span class="hljs-type">UInt8</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">//255</span></code></pre></div><p><strong>3、浮点型 Float\Double</strong></p><p><code>浮点型</code>用来存放小数，其中Float为单精度，存放32位；Double为双精度，存放64位<br>Double可以保证15位小数精度，Float保证6位小数精度，如果超出精确度会有问题</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> float:<span class="hljs-type">Float</span> = <span class="hljs-number">0.123456</span><span class="hljs-keyword">var</span> double:<span class="hljs-type">Double</span> = <span class="hljs-number">0.012345678912345</span></code></pre></div><p><strong>4、字符与字符串 String\Char</strong><br><code>String</code>用来存放一串字符，可以是字母，数字，符号等，使用<code>“”</code>双引号赋值</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> str:<span class="hljs-type">String</span> = <span class="hljs-string">"hello，world！"</span></code></pre></div><p><code>Char</code>用来存放字符，是Charactor的缩写,同样用双引号赋值</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> char:<span class="hljs-type">String</span> = <span class="hljs-string">"H"</span></code></pre></div><p><strong>部分转义</strong><br>因为在一些情况下，直接使用符号可能会造成混乱导致编译失败，或者我们要实现别的功能,我们可以使用\来进行转义</p><div class="hljs"><pre><code class="hljs swift">\t 制表\r 回车\n 换行\' 单引号\'' 双引号\\ 反斜杠\<span class="hljs-number">0</span> 空字符</code></pre></div><h2 id="元祖-Tuple"><a href="#元祖-Tuple" class="headerlink" title="元祖 Tuple"></a>元祖 Tuple</h2><p><code>元祖</code>是多个元素相关联的一个对象，Tuple（Type1,Type2,…）</p><p><code>匿名元祖</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple1:(<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Bool</span>) = (<span class="hljs-string">"张三"</span>,<span class="hljs-number">23</span>,<span class="hljs-literal">true</span>)<span class="hljs-comment">//匿名元祖只能点下标来取值</span>tuple1.<span class="hljs-number">0</span> <span class="hljs-comment">//输出为张三</span></code></pre></div><p><code>非匿名元祖</code> 优先使用</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple2:(name:<span class="hljs-type">String</span>,age:<span class="hljs-type">Int</span>,gender:<span class="hljs-type">Bool</span>) = (name:<span class="hljs-string">"李四"</span>,age:<span class="hljs-number">24</span>,gender:<span class="hljs-literal">true</span>)tuple2.name<span class="hljs-comment">//输出为李四</span></code></pre></div><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><p><code>数组</code>是一个同种类型的集合<br>数组的一种声明方式</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> array:<span class="hljs-type">Array</span><<span class="hljs-type">Int</span>> = <span class="hljs-type">Array</span><<span class="hljs-type">Int</span>>()</code></pre></div><p>数组的声明方式2</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> array2:[<span class="hljs-type">Int</span>] = [<span class="hljs-type">Int</span>]()</code></pre></div><p>直接声明</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> array3 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</code></pre></div><p>数组如何添加</p><div class="hljs"><pre><code class="hljs swift">array.append(<span class="hljs-number">0</span>)array.append(<span class="hljs-number">6</span>)array.append(<span class="hljs-number">8</span>)array.append(<span class="hljs-number">5</span>)</code></pre></div><p><strong>数组的下标(索引) 是从0开始计算的</strong></p><p>数组的访问</p><div class="hljs"><pre><code class="hljs swift">array[<span class="hljs-number">0</span>]array[<span class="hljs-number">1</span>]array[<span class="hljs-number">3</span>]</code></pre></div><p>数组的插入</p><div class="hljs"><pre><code class="hljs swift">array.insert(<span class="hljs-number">3</span>, at: <span class="hljs-number">0</span>) <span class="hljs-comment">//把数字3插入下标0</span></code></pre></div><p>数组删除</p><div class="hljs"><pre><code class="hljs swift">array.remove(at: <span class="hljs-number">3</span>)</code></pre></div><p>数组的排序</p><div class="hljs"><pre><code class="hljs swift">array.<span class="hljs-built_in">sort</span>(by:>)</code></pre></div><p><strong>多维数组</strong><br>声明方式1:</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> multiArray:[[<span class="hljs-type">Int</span>]] = [[<span class="hljs-type">Int</span>]]()</code></pre></div><p>声明方式2:</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> multiArray2 = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]</code></pre></div><h2 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 Dictionary"></a>字典 Dictionary</h2><p><code>Dictionary</code>是以键值对的方式存储数据</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> dic:<span class="hljs-type">Dictionary</span><<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>> = <span class="hljs-type">Dictionary</span><<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>>()<span class="hljs-comment">//新华字典 用名字找页号的例子</span>dic[<span class="hljs-string">"安"</span>] = <span class="hljs-number">7</span>dic[<span class="hljs-string">"周"</span>] = <span class="hljs-number">361</span></code></pre></div><p>字典如何移除</p><div class="hljs"><pre><code class="hljs swift">dic.remove(at: dic.index(forKey: <span class="hljs-string">"周"</span>)!)</code></pre></div><p>显示字典的键、值</p><div class="hljs"><pre><code class="hljs swift">dic.valuesdic.keys</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;期末考试周&quot;&gt;&lt;a href=&quot;#期末考试周&quot; class=&quot;headerlink&quot; title=&quot;期末考试周&quot;&gt;&lt;/a&gt;期末考试周&lt;/h2&gt;&lt;p&gt;整理一下考试用到的Swift的基本语法，权当复习，一共会有四篇。本篇包含了注释，变量，常量，声明方式，数据类型，元祖，数组，字典。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Swift" scheme="http://yancc.cc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>联想小新13Pro 更换开机页面</title>
    <link href="http://yancc.cc/2020/06/24/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0Pro13%20%E6%9B%B4%E6%8D%A2%E5%BC%80%E6%9C%BA%E9%A1%B5%E9%9D%A2/"/>
    <id>http://yancc.cc/2020/06/24/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0Pro13%20%E6%9B%B4%E6%8D%A2%E5%BC%80%E6%9C%BA%E9%A1%B5%E9%9D%A2/</id>
    <published>2020-06-24T09:50:20.000Z</published>
    <updated>2021-01-15T11:46:59.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要修改？"><a href="#为什么要修改？" class="headerlink" title="为什么要修改？"></a>为什么要修改？</h2><p>联想小新的开机页面太丑了，找遍论坛也没有个替换方法。研究了一下，发现修改开机logo是要更改BIOS的，找遍网络发现一个开源工具<code>HackBGRT</code>，可以很快的实现。（请先看注意事项，再操作）</p><a id="more"></a><p><del>（原本的开机页面像天猫logo不说，还是七彩的）</del></p><h2 id="步骤一：下载开源软件HackBGRT"><a href="#步骤一：下载开源软件HackBGRT" class="headerlink" title="步骤一：下载开源软件HackBGRT"></a>步骤一：下载开源软件HackBGRT</h2><p>在发布页面下好软件后，解压。</p><p><img src="/img/thkj02.png" srcset="/img/loading.gif" alt="下载解压"></p><blockquote><ul><li>GitHub地址 ：<a href="https://github.com/Metabolix/HackBGRT/releases" target="_blank" rel="noopener">https://github.com/Metabolix/HackBGRT/releases</a></li></ul></blockquote><h2 id="步骤二：安装软件"><a href="#步骤二：安装软件" class="headerlink" title="步骤二：安装软件"></a>步骤二：安装软件</h2><p>需要使用管理员权限来打开Setup.exe，在弹出的cmd窗口下，输入<strong>I (大写)</strong>，来进行安装，安装过后会弹出一个文本文档，我们选择关闭。</p><p><img src="/img/thkj03.png" srcset="/img/loading.gif" alt="安装软件"></p><h2 id="步骤三：修改图片"><a href="#步骤三：修改图片" class="headerlink" title="步骤三：修改图片"></a>步骤三：修改图片</h2><p>正常来说，上一步操作过后会弹出一个画图的窗口，这时候我们就可以把我们想要的开机图片提前修改好，然后<strong>拷贝</strong>到里面，覆盖掉原始图片，保存即可。</p><p><img src="/img/thkj04.png" srcset="/img/loading.gif" alt="修改图片"></p><h2 id="步骤四：完成-amp-注意事项"><a href="#步骤四：完成-amp-注意事项" class="headerlink" title="步骤四：完成&注意事项"></a>步骤四：完成&注意事项</h2><p>重启即可，我们可以看到现在的开机页面已经变成了我们修改的图片。<del>（果然联想电脑还是应该用联想的logo）</del></p><p><img src="/img/thkj05.png" srcset="/img/loading.gif" alt="完成"></p><hr><h2 id="注意事项（请优先观看）"><a href="#注意事项（请优先观看）" class="headerlink" title="注意事项（请优先观看）"></a>注意事项（请优先观看）</h2><p>1.系统需要为UEFI引导，请提前查看Boot Mode启动方式<br>2.需要关闭Secure Boot (既把Secure Boot设置为Disabled)<br>3.请直接替换画图里的图片，并非软件目录中的splash.bmp<br>4.如果需要换回原来的的开机画面，只需要再次Setup.exe 输入 R 即可恢复<br>5.如果不走运无法开机，请使用系统恢复修复启动问题<br>6.系统更新后可能会失效，需要重新设置(2020.08.05补充)</p><p>7.最新版的联想电脑管家已经可以实现此功能（2021.01.15）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;为什么要修改？&quot;&gt;&lt;a href=&quot;#为什么要修改？&quot; class=&quot;headerlink&quot; title=&quot;为什么要修改？&quot;&gt;&lt;/a&gt;为什么要修改？&lt;/h2&gt;&lt;p&gt;联想小新的开机页面太丑了，找遍论坛也没有个替换方法。研究了一下，发现修改开机logo是要更改BIOS的，找遍网络发现一个开源工具&lt;code&gt;HackBGRT&lt;/code&gt;，可以很快的实现。（请先看注意事项，再操作）&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://yancc.cc/tags/日常/"/>
    
    <category term="小技巧" scheme="http://yancc.cc/tags/小技巧/"/>
    
  </entry>
  
  <entry>
    <title>从网易云导入音乐到Apple Music</title>
    <link href="http://yancc.cc/2019/07/22/%E4%BB%8E%E7%BD%91%E6%98%93%E4%BA%91%E5%AF%BC%E5%85%A5%E9%9F%B3%E4%B9%90%E5%88%B0AppleMusic/"/>
    <id>http://yancc.cc/2019/07/22/%E4%BB%8E%E7%BD%91%E6%98%93%E4%BA%91%E5%AF%BC%E5%85%A5%E9%9F%B3%E4%B9%90%E5%88%B0AppleMusic/</id>
    <published>2019-07-22T11:47:13.000Z</published>
    <updated>2021-01-07T09:37:07.827Z</updated>
    
    <content type="html"><![CDATA[<p>随着<code>网易云音乐</code>的版权越来越少，功能越来越臃肿，歌词被和谐，我决定换到<code>Apple Music</code>一段时间试试，但由于网易云每个歌单都有好几百首音乐，如果一首一首的导入太麻烦了，便开始研究如何将歌单完美导入。</p><a id="more"></a> <p>采用的方法是：<code>Apple Music</code>资料库里有的音乐，使用<code>TunemyMusic</code>来导入，库里没有的音乐使用<code>iCloud音乐库</code>来进行云播放。</p><p>下面是具体方法：</p><h2 id="步骤一：下载浏览器的油猴插件"><a href="#步骤一：下载浏览器的油猴插件" class="headerlink" title="步骤一：下载浏览器的油猴插件"></a>步骤一：下载浏览器的油猴插件</h2><p><img src="/img/wa11.png" srcset="/img/loading.gif" alt="header"></p><blockquote><ul><li>油猴安装教程 ：<a href="https://zhuanlan.zhihu.com/p/52182666" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52182666</a></li></ul></blockquote><h2 id="步骤二：安装油猴脚本，并启动"><a href="#步骤二：安装油猴脚本，并启动" class="headerlink" title="步骤二：安装油猴脚本，并启动"></a>步骤二：安装油猴脚本，并启动</h2><p><img src="/img/wa12.png" srcset="/img/loading.gif" alt="header"></p><blockquote><ul><li>安装网址 ：<a href="http://t.cn/AilEhyvb" target="_blank" rel="noopener">http://t.cn/AilEhyvb</a></li></ul></blockquote><h2 id="步骤三：网易云分享歌单，导出txt格式文件"><a href="#步骤三：网易云分享歌单，导出txt格式文件" class="headerlink" title="步骤三：网易云分享歌单，导出txt格式文件"></a>步骤三：网易云分享歌单，导出txt格式文件</h2><p><img src="/img/wa13.png" srcset="/img/loading.gif" alt="header"><br>以链接的方式分享你想要导入<code>Apple Music</code>的歌单，用安装了油猴脚本的浏览器打开，选择导出。<br><img src="/img/wa14.png" srcset="/img/loading.gif" alt="header"><br>下载后打开，会获得如下所示：<br><img src="/img/wa15.png" srcset="/img/loading.gif" alt="header"></p><h2 id="步骤四：使用TunemyMusic来导入音乐到Apple-Music"><a href="#步骤四：使用TunemyMusic来导入音乐到Apple-Music" class="headerlink" title="步骤四：使用TunemyMusic来导入音乐到Apple Music"></a>步骤四：使用TunemyMusic来导入音乐到Apple Music</h2><blockquote><ul><li>进入官网 ：<a href="https://www.tunemymusic.com/zh-cn/" target="_blank" rel="noopener">https://www.tunemymusic.com/zh-cn/</a></li></ul></blockquote><p>在来源选择中选择<code>从文本</code>：<br><img src="/img/wa16.png" srcset="/img/loading.gif" alt="header"><br>如图所示，将刚才的文本内容粘贴至此：<br><img src="/img/wa17.png" srcset="/img/loading.gif" alt="header"><br>选择目的地为<code>Apple Music</code>，并登录<code>Apple ID</code>：<br><img src="/img/wa18.png" srcset="/img/loading.gif" alt="header"><br>登陆完成就可以看到已经开始向<code>Apple Music</code>添加了，剩下的等着就好。<br><img src="/img/wa19.png" srcset="/img/loading.gif" alt="header"><br>其余导入失败可以从网易云下载，使用<code>iTunes</code>播放，就会自动添加进<code>iCloud音乐库</code>了。<br><img src="/img/wa110.png" srcset="/img/loading.gif" alt="header"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着&lt;code&gt;网易云音乐&lt;/code&gt;的版权越来越少，功能越来越臃肿，歌词被和谐，我决定换到&lt;code&gt;Apple Music&lt;/code&gt;一段时间试试，但由于网易云每个歌单都有好几百首音乐，如果一首一首的导入太麻烦了，便开始研究如何将歌单完美导入。&lt;/p&gt;</summary>
    
    
    
    
    <category term="日常" scheme="http://yancc.cc/tags/日常/"/>
    
    <category term="小技巧" scheme="http://yancc.cc/tags/小技巧/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yancc.cc/2019/07/18/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/"/>
    <id>http://yancc.cc/2019/07/18/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/</id>
    <published>2019-07-18T10:43:04.000Z</published>
    <updated>2020-07-12T12:06:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>花了3个晚上终于把这个鬼东西整的差不多了。<br>不知道写点儿啥，就先这样子。</p><a id="more"></a> <hr><p><img src="/img/demo.jpg" srcset="/img/loading.gif" alt="header"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    <summary type="html">&lt;p&gt;花了3个晚上终于把这个鬼东西整的差不多了。&lt;br&gt;不知道写点儿啥，就先这样子。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
