<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UGUI 学习笔记</title>
    <link href="/2021/01/04/UGUI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/04/UGUI%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>UGUI 相关学习记录，目前：画布</p><a id="more"></a><h1 id="画布"><a href="#画布" class="headerlink" title="画布"></a>画布</h1><h2 id="UI元素的渲染顺序"><a href="#UI元素的渲染顺序" class="headerlink" title="UI元素的渲染顺序"></a>UI元素的渲染顺序</h2><ul><li>根据hierarchy依次渲染</li></ul><h3 id="用代码更改渲染方式"><a href="#用代码更改渲染方式" class="headerlink" title="用代码更改渲染方式"></a>用代码更改渲染方式</h3><p>Transform/RectTransform的SetAsFirstSibling() / SetAsLastSibling() / SetSibingIndex()的方法实现</p><h2 id="画布渲染模式与属性"><a href="#画布渲染模式与属性" class="headerlink" title="画布渲染模式与属性"></a>画布渲染模式与属性</h2><h3 id="Screen-Space-Overlay"><a href="#Screen-Space-Overlay" class="headerlink" title="Screen Space - Overlay"></a>Screen Space - Overlay</h3><p>画布无论在场景何处都会渲染覆盖整个画面，会随着游戏视图大小而改变</p><ul><li><p>Pixel Perfect</p><p>UI内像素渲染统一</p></li><li><p>Sort Order</p><p>通过数值设置画布上的渲染顺序，越小内侧优先，越大外侧优先</p></li></ul><h3 id="Screen-Space-Camera"><a href="#Screen-Space-Camera" class="headerlink" title="Screen Space-Camera"></a>Screen Space-Camera</h3><p>画布通过指定的摄像机进行渲染</p><p>摄像机会影响到UI元素的呈现效果，如果摄像机的Projection的属性被设置为Perspective的话，UI就会略带透明效果（透明度跟着摄像机的Field of view）的属性变化</p><p>画布会自适应对着摄像机的视口调整大小、位置、朝向、以正面面对摄像机</p><ul><li><p>Pixel Perfect</p><p>UI内像素渲染统一</p></li><li><p>Rander Camera</p><p>指定渲染的摄像机</p></li><li><p>Plane Distance</p><p>设置从画布到摄像机的距离</p></li><li><p>Sorting Layer</p><p>控制渲染顺序但与distance(Z)无关</p></li><li><p>Order in Layer</p><p>通过数值设置画布上的渲染顺序，越小内侧优先，越大外侧优先</p></li></ul><h3 id="World-Space"><a href="#World-Space" class="headerlink" title="World Space"></a>World Space</h3><p>与场景内其他游戏对象一样处理，画布由Rect Transform组件来定义</p><p>按照3D空间上的位置关系进行渲染</p><p>适用于将UI元素作为场景的一部分来处理的情况</p><ul><li><p>Event Camera</p><p>指定处理事件的摄像机</p></li><li><p>Sorting Layer 、Order in Layer</p><p>同上</p></li></ul><h2 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h2><h4 id="Ui-Scale-Mode"><a href="#Ui-Scale-Mode" class="headerlink" title="Ui Scale Mode"></a>Ui Scale Mode</h4><ul><li><p>Constant Pixel Size 根据画布的UI元素比例和像素密度来设置，会影响画布内的所有元素</p><ul><li><p>Scale Factor </p><p>UI缩放的系数</p></li><li><p>Refence Pixels Per Unit</p><p>标准单位的像素数</p></li></ul></li><li><p>Scale With Screen Size 根据分辨率来创建UI</p><ul><li><p>Reference Resolution</p><p> 设置缩创建UI的标准分辨率</p></li><li><p>Screen Match Mode</p><p>设置画布宽高比不同时的缩放</p></li><li><p>Match Width Or Height | Match值为（0.0-1.0）</p><p>结合分辨率的宽高缩放画布</p></li><li><p>Expand</p><p>扩展画布，但分辨率不降低</p></li><li><p>Shrink</p><p>收缩画布的区域、画布的宽高同时收缩，均不超过参照分辨率</p></li><li><p>Reference Pixels Per Unit</p><p>设置画布上，每个单位的标准像素数</p></li></ul></li><li><p>World 当画布渲染模式为World Space时，Ui Scale Mode属性的固定值</p><ul><li><p>Dynamic Pixels Per Unit</p><p>与文本一样，设置UI上动态生成图形的每单位像素数</p></li><li><p>Reference Pixels Per Unit</p><p>设置画布上，每个单位的标准像素数</p></li></ul></li></ul><h2 id="Graphic-Raycaster"><a href="#Graphic-Raycaster" class="headerlink" title="Graphic Raycaster"></a>Graphic Raycaster</h2><p>EventSystem的核心是Raycasting机制</p><p>本质是从某个坐标到其他坐标渲染的一条假象的直线，称为Ray，起作用是检测与场景上对象之间冲突的机制</p><p>通过Graphic Raycaster可以判断用户操作的UI元素是画布上的哪个UI元素</p><h3 id="Ignore-Reversed-Graphics"><a href="#Ignore-Reversed-Graphics" class="headerlink" title="Ignore Reversed Graphics"></a>Ignore Reversed Graphics</h3><p>忽略反转并显示了背面的图形</p><h3 id="Blocking-Objects"><a href="#Blocking-Objects" class="headerlink" title="Blocking Objects"></a>Blocking Objects</h3><p>指定阻挡光线投射的对象</p><ul><li>None</li><li>2D</li><li>3D</li><li>ALL</li></ul><h3 id="Blocking-Mask"><a href="#Blocking-Mask" class="headerlink" title="Blocking Mask"></a>Blocking Mask</h3><p>指定阻挡光线投射的对象的层</p><h2 id="Canvas-Renderer"><a href="#Canvas-Renderer" class="headerlink" title="Canvas Renderer"></a>Canvas Renderer</h2><p>画布中所有图形元素都附加了~组件，作用是元素渲染到画布 </p><h2 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h2><p>通过画布组将多个UI元素分组，统一设定或修改某个属性</p><ul><li><p>Alpha</p><p>设置不透明度(0~1.0)</p><p>如果UI元素一又Alpha值，就会使用相乘后所得的值</p></li><li><p>Interactable</p><p>设置画布组内的UI元素是有效还是无效状态</p></li><li><p>Blocks Raycasts</p><p>设置画布组内的所有UI元素是否阻挡管线投射（判断碰撞）</p><p>多适用于HUD上的状态显示或指示器</p></li><li><p>Ignore Parent Groups</p><p>画布被嵌套时，忽略在父级画布组的属性</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>UGUI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021新年</title>
    <link href="/2021/01/01/2021Year/"/>
    <url>/2021/01/01/2021Year/</url>
    
    <content type="html"><![CDATA[<h1 id="新年愿望"><a href="#新年愿望" class="headerlink" title="新年愿望"></a>新年愿望</h1><p>希望可以健健康康的度过2021年。</p><a id="more"></a><ul><li><input disabled type="checkbox"> <p>找到一份满意的实习</p></li><li><input disabled type="checkbox"> <p>可以一个人生活</p></li><li><input disabled type="checkbox"> <p>维系社交关系</p></li><li><input disabled type="checkbox"> <p>学会Lua / Python</p></li><li><input disabled type="checkbox"> <p>认真的记录生活</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C# 查缺补漏</title>
    <link href="/2020/12/30/C#%20Learning/"/>
    <url>/2020/12/30/C#%20Learning/</url>
    
    <content type="html"><![CDATA[<p>C# 查缺补漏专栏，持续更新</p><a id="more"></a><h1 id="2020-08-06-更新："><a href="#2020-08-06-更新：" class="headerlink" title="2020.08.06 更新："></a>2020.08.06 更新：</h1><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><div class="hljs"><pre><code class="hljs csharp">Console.WriteLine(<span class="hljs-string">"{0}+{1}={2}"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);</code></pre></div><h2 id="使用-不识别转义字符"><a href="#使用-不识别转义字符" class="headerlink" title="使用@不识别转义字符"></a>使用@不识别转义字符</h2><p>如果不想识别字符串中的转义字符，可以在字符串前面加一个@符号（除双引号外，如果表一个双引号则需要两个）</p><ul><li>使用场景多在表示路径</li><li>把一个字符串定义在多行</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>ctrl+k ctrl+c 注释选中行</li><li>ctrl+k ctrl+u 取消注释选中行</li></ul><blockquote><p>2020.08.08 更新：</p></blockquote><h2 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h2><p>C#中将string类型转换为float类型时，不应该使用Convert.ToFloat()方法，正确的方法为Convert.ToSingle()</p><p>查了一下，在C#的基类库中single是浮点的名称，float为别名</p><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&和&&的区别"></a>&和&&的区别</h2><h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>通过定义标签直接控制程序跳转到标签位置</p><p>缺点：</p><ul><li>降低代码可读性</li><li>使得代码复杂</li><li>和程序访问的局部性原理相违背</li></ul><h1 id="2020-12-30"><a href="#2020-12-30" class="headerlink" title="2020.12.30"></a>2020.12.30</h1><p>今天又忘了C#里没有Convert.ToFloat，只有Convet.ToSingle。</p><h1 id="2020-12-31"><a href="#2020-12-31" class="headerlink" title="2020.12.31"></a>2020.12.31</h1><h2 id="属性和字段的比较"><a href="#属性和字段的比较" class="headerlink" title="属性和字段的比较"></a>属性和字段的比较</h2><ul><li>属性可以实现只读或只写，字段不行</li><li>属性的set方法可以对用户指定的value，进行有效检查，从而保证只有正确的状态才会得到设置，字段不行</li><li>属性的get方法不仅可以返回字段变量的值，可以返回一些经过计算或处理过的数据</li><li>由于属性在实现时，实际上是方法，所以可以具有方法的一些优点</li></ul><h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><ul><li>在类的内部记录事物的状态信息，则用字段变量</li><li>字段变量一般用private修饰，以防止对外使用</li><li>对外公布事物的状态信息，则使用属性</li><li>属性一般与某个或某几个字段变量有对应关系</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>暑期学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Mac迁移Hexo至Windows</title>
    <link href="/2020/09/11/%E4%BB%8EMac%E8%BF%81%E7%A7%BBHexo%E8%87%B3Windows/"/>
    <url>/2020/09/11/%E4%BB%8EMac%E8%BF%81%E7%A7%BBHexo%E8%87%B3Windows/</url>
    
    <content type="html"><![CDATA[<p>害挺麻烦的。</p><a id="more"></a><p>= =#，都忘了这回事了，大概说说流程。</p><ol><li>安装Git </li><li>弄好SSH key </li><li>安装Node.js（🕳，这里不能安装过高的版本）</li><li>安装hexo </li><li>把源Hexo文件夹拷贝到新电脑中</li><li>切到拷贝过来的文件夹，npm install</li><li>安装核心组件<ul><li>hexo-deployer-git </li><li>hexo-generator-feed</li><li>hexo-generator-sitemap </li></ul></li><li>hexo g -d 部署完成，迁移成功</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity官方课程学习记录 2020.07.20-22</title>
    <link href="/2020/07/20/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.20-22/"/>
    <url>/2020/07/20/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.20-22/</url>
    
    <content type="html"><![CDATA[<p>老阶段性测试了+水果忍者原型实现，完结撒花<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</p><a id="more"></a><h1 id="Day-7-踢足球-阶段性测试"><a href="#Day-7-踢足球-阶段性测试" class="headerlink" title="Day 7 踢足球 + 阶段性测试"></a>Day 7 踢足球 + 阶段性测试</h1><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>滚动操作球，把对方的球踢入它的球门</li><li>敌人全部消失后进入下一个场，每场多一个</li><li>滚动冲刺</li><li>粒子效果</li><li>增益buff</li></ul><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/img/u4c0.gif" srcset="/img/loading.gif" alt="效果图"></p><h2 id="Debug方式"><a href="#Debug方式" class="headerlink" title="Debug方式"></a>Debug方式</h2><ul><li>优先运行游戏运行时控制台的报错，再讨论机制问题</li></ul><h2 id="官方测试题"><a href="#官方测试题" class="headerlink" title="官方测试题"></a>官方测试题</h2><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><img src="/img/u4c1.png" srcset="/img/loading.gif" alt="1"></p><h3 id="答案：D"><a href="#答案：D" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="/img/u4c2.png" srcset="/img/loading.gif" alt="2"></p><h3 id="答案：B"><a href="#答案：B" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><img src="/img/u4c3.png" srcset="/img/loading.gif" alt="3"></p><h3 id="答案：A"><a href="#答案：A" class="headerlink" title="答案：A"></a>答案：A</h3><h3 id="解析：b里面的-变成-，vector3中只可以使用乘，唯有A可以解决报错"><a href="#解析：b里面的-变成-，vector3中只可以使用乘，唯有A可以解决报错" class="headerlink" title="解析：b里面的=变成+，vector3中只可以使用乘，唯有A可以解决报错"></a>解析：b里面的=变成+，vector3中只可以使用乘，唯有A可以解决报错</h3><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p><img src="/img/u4c4.png" srcset="/img/loading.gif" alt="4"></p><h3 id="答案：A-1"><a href="#答案：A-1" class="headerlink" title="答案：A"></a>答案：A</h3><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><img src="/img/u4c5.png" srcset="/img/loading.gif" alt="5"></p><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><img src="/img/u4c6.png" srcset="/img/loading.gif" alt="6"></p><h3 id="答案：D-1"><a href="#答案：D-1" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p><img src="/img/u4c7.png" srcset="/img/loading.gif" alt="7"></p><h3 id="答案：B-1"><a href="#答案：B-1" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p><img src="/img/u4c8.png" srcset="/img/loading.gif" alt="8"></p><h3 id="答案：B-2"><a href="#答案：B-2" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p><img src="/img/u4c9.png" srcset="/img/loading.gif" alt="9"></p><h3 id="答案：D-2"><a href="#答案：D-2" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><img src="/img/u4cX.png" srcset="/img/loading.gif" alt="10"></p><h3 id="答案：E"><a href="#答案：E" class="headerlink" title="答案：E"></a>答案：E</h3><hr><h1 id="Day-8-水果忍者原型实现"><a href="#Day-8-水果忍者原型实现" class="headerlink" title="Day 8 水果忍者原型实现"></a>Day 8 水果忍者原型实现</h1><p>今天开发的是一个水果忍者游戏的原型，马上这个系列的课就学完了，终于要开始下一阶段的学习了！</p><!-- more --><h2 id="游戏实现-1"><a href="#游戏实现-1" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>一个简易的开始菜单，可以选择难度</li><li>一个简易的Game Over菜单</li><li>会从屏幕下方弹出水果和炸弹，点到水果会加分，点到炸弹会扣分</li><li>当水果没有被点到且掉出下方边界时候，游戏结束</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ul><li>通过创建SpawnManager来控制随机物品的生成</li><li>设置游戏选择难度按钮，选择难度后SpawnManager开始生成</li><li>通过设置一条触发器来判断游戏结束</li><li>游戏结束时候会弹出GameOver的信息以及restart按钮</li></ul><h2 id="GameManager"><a href="#GameManager" class="headerlink" title="GameManager"></a>GameManager</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> TMPro;<span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> List<GameObject> targetPrefebs; <span class="hljs-comment">//list列表 可以用add，remove方法添加或删除</span>  <span class="hljs-comment">//public GameObject[] target;          //数组 占用固定的内存无法添加</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">10.0f</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> spawnRate = <span class="hljs-number">1.0f</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> gameStarted;    <span class="hljs-keyword">public</span> TextMeshProUGUI scoreText;    <span class="hljs-keyword">public</span> GameObject gameOver;    <span class="hljs-keyword">public</span> GameObject mainMenu;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-function">IEnumerator <span class="hljs-title">SpawnTarget</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">while</span> (gameStarted)        {            <span class="hljs-function"><span class="hljs-keyword">yield</span> return new <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">spawnRate</span>)</span>;            <span class="hljs-keyword">int</span> index = Random.Range(<span class="hljs-number">0</span>, targetPrefebs.Count);            Instantiate(targetPrefebs[index]);        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateSource</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> scoreToAdd</span>)</span>    {        score += scoreToAdd;        scoreText.text = <span class="hljs-string">"Score:"</span> + score;    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameIsOver</span>(<span class="hljs-params"></span>)</span> {        gameStarted = <span class="hljs-literal">false</span>;        gameOver.SetActive(<span class="hljs-literal">true</span>);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RestartGame</span>(<span class="hljs-params"></span>)</span>     {        SceneManager.LoadScene(SceneManager.GetActiveScene().name);    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartNewGame</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> switchD</span>)</span> {        spawnRate /= switchD;        gameStarted = <span class="hljs-literal">true</span>;        StartCoroutine(SpawnTarget());        mainMenu.SetActive(<span class="hljs-literal">false</span>);    }}</code></pre></div><h3 id="数组与ArrayList与List"><a href="#数组与ArrayList与List" class="headerlink" title="数组与ArrayList与List"></a>数组与ArrayList与List</h3><ul><li>数组<ul><li>内存中是连续存储的，所以它的索引速度非常快，而且赋值与修改元素也很简单</li><li>不足：<ul><li>需要指定长度，当长度过长时会造成内存浪费</li><li>如果不确定长度的时候也会很麻烦</li></ul></li></ul></li><li>ArrayList<ul><li>命名空间System.Collections下的一部分，在使用该类时必须进行引用</li><li>继承了IList接口，提供了数据存储和检索</li><li>ArrayList对象的大小是按照其中存储的数据来动态扩充与收缩的，不需要指定长度</li><li>不足：<ul><li>ArrayList不是类型安全的</li><li>存储或检索值类型时通常发生装箱和取消装箱操作，带来很大的性能耗损</li></ul></li></ul></li><li>List<ul><li>List类是ArrayList类的泛型等效类</li><li>大部分用法都与ArrayList相似，因为List类也继承了IList接口</li><li>在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</li></ul></li></ul><h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Target</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    GameManager gameManager;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> point;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> miniSpeed = <span class="hljs-number">12</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> maxSpeed = <span class="hljs-number">16</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> maxTorque = <span class="hljs-number">10</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> xRange = <span class="hljs-number">4</span>;    <span class="hljs-keyword">public</span> ParticleSystem explosionParticle;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        gameManager = FindObjectOfType<GameManager>();        rb = GetComponent<Rigidbody>();        rb.AddForce(RandomSpeed(), ForceMode.Impulse);        rb.AddTorque(RandomTorque(), RandomTorque(), RandomTorque());        transform.position = RandomSpawnPos();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>    {        Destroy(gameObject);        <span class="hljs-keyword">if</span> (!gameObject.CompareTag(<span class="hljs-string">"Bad"</span>))        {            gameManager.GameIsOver();        }          }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseDown</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (gameManager.gameStarted)        {            Instantiate(explosionParticle, transform.position, explosionParticle.transform.rotation);            gameManager.UpdateSource(point);            Destroy(gameObject);        }            }    <span class="hljs-function">Vector3 <span class="hljs-title">RandomSpeed</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">return</span> Vector3.up * Random.Range(miniSpeed, maxSpeed); <span class="hljs-comment">// 因为乘了vector3.up 所以有个初始值</span>    }    <span class="hljs-function">Vector3 <span class="hljs-title">RandomSpawnPos</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vector3(Random.Range(-xRange, xRange), <span class="hljs-number">-1f</span>, <span class="hljs-number">0</span>);    }    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">RandomTorque</span>(<span class="hljs-params"></span>)</span> {        <span class="hljs-keyword">return</span> Random.Range(-maxTorque, maxTorque);    }}</code></pre></div><h2 id="SwitchDifficulty"><a href="#SwitchDifficulty" class="headerlink" title="SwitchDifficulty"></a>SwitchDifficulty</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> UnityEngine.UI;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SwithcDifficulty</span> : <span class="hljs-title">MonoBehaviour</span>{    Button button;    GameManager gameManager;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> difficulty;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        button = GetComponent<Button>();        gameManager = FindObjectOfType<GameManager>();        button.onClick.AddListener(SetDifficulty);    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetDifficulty</span>(<span class="hljs-params"></span>)</span> {        gameManager.StartNewGame(difficulty);    }}</code></pre></div><h2 id="Rigidbody-AddTorque"><a href="#Rigidbody-AddTorque" class="headerlink" title="Rigidbody.AddTorque"></a>Rigidbody.AddTorque</h2><ul><li>向刚体添加扭矩</li><li>只能应用于处于活动状态的刚体。如果 GameObject 处于非活动状态，则 AddTorque 没有效果</li><li>默认将唤醒刚体。如果扭矩大小为零，则不会唤醒刚体</li><li>添加prefeb不能一起添加，只能一个一个添加</li><li>更改变量类型后要回到面板看看数值有没有丢失</li></ul><h2 id="GameManager-1"><a href="#GameManager-1" class="headerlink" title="GameManager"></a>GameManager</h2><h2 id="OnMouseDown"><a href="#OnMouseDown" class="headerlink" title="OnMouseDown()"></a>OnMouseDown()</h2><ul><li>在移动平台也可以用</li><li>物体要有碰撞器才有效果</li></ul><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ul><li>画布 (Canvas) 是应该容纳所有 UI 元素的区域</li><li>画布是一种带有画布组件的游戏对象</li><li>所有 UI 元素都必须是此类画布的子项<ul><li>如果场景中没有画布，那么创建任何一个UI元素，都会自动创建画布，并且将新元素置于其下</li></ul></li></ul><h3 id="TEXT-TMP"><a href="#TEXT-TMP" class="headerlink" title="TEXT TMP"></a>TEXT TMP</h3><ul><li>命名空间：</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> TMPro;</code></pre></div><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><ul><li>需引入命名空间：</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;</code></pre></div><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><h3 id="Canvas-Scaler"><a href="#Canvas-Scaler" class="headerlink" title="Canvas Scaler"></a>Canvas Scaler</h3><ul><li>用来适应不同的屏幕大小</li><li>留坑() 以后看UGUI的时候再回来补</li></ul><h2 id="场景重载"><a href="#场景重载" class="headerlink" title="场景重载"></a>场景重载</h2><ul><li>命名空间</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> UnityEngine.SceneManagement</code></pre></div><p>LoadScene(string)传入场景名称，达到载入场景的效果</p><p>gameObject.GetActiveScene().name，获得物体的场景，可直接传入LoadScene()以达到重新开始的效果</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>添加prefeb不能一起添加，只能一个一个添加</li><li>更改变量类型后要回到面板看看数值有没有丢失</li></ul><hr><h1 id="Day-9-修修补补，课程完结"><a href="#Day-9-修修补补，课程完结" class="headerlink" title="Day 9 修修补补，课程完结"></a>Day 9 修修补补，课程完结</h1><h2 id="游戏实现-2"><a href="#游戏实现-2" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>有倒计时，获得尽可能高的分数</li><li>当忘记点了good物体则游戏失败</li><li>难度选择以及重新开始</li></ul><h2 id="Mathf-Round"><a href="#Mathf-Round" class="headerlink" title="Mathf.Round"></a>Mathf.Round</h2><ul><li>四舍六入五取偶数</li></ul><h2 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h2><ul><li>在Hierarchy面板中，按住 <code>Alt</code> 可以打开一个物体的所有的子目录</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>暑期学习</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity官方课程学习记录 2020.07.16-19</title>
    <link href="/2020/07/16/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.16-19/"/>
    <url>/2020/07/16/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.16-19/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-4-跑酷小游戏"><a href="#Day-4-跑酷小游戏" class="headerlink" title="Day 4 跑酷小游戏"></a>Day 4 跑酷小游戏</h1><p>一个跑酷的小游戏和滚动小球儿，感觉还挺有趣的。</p><p>内附10道测试题。</p><a id="more"></a><h2 id="游戏要实现的功能"><a href="#游戏要实现的功能" class="headerlink" title="游戏要实现的功能"></a>游戏要实现的功能</h2><p>玩家通过 <code>空格</code> 实现跳跃，完成跨越障碍的动作，如果碰到障碍则游戏结束输出game over，同时需要有特效和音乐音效</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><ul><li>通过给player添加脚本实现跳跃跨越障碍，游戏结束判定</li><li>通过给Ground和Background添加脚本设置背景后移</li><li>设置spawnManager以及脚本用来生成障碍</li></ul><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><h3 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    <span class="hljs-keyword">private</span> Animator anim;<span class="hljs-comment">//获得动画组件</span>    <span class="hljs-keyword">private</span> AudioSource audioSource;<span class="hljs-comment">//获得声音组件</span><span class="hljs-keyword">public</span> AudioClip crashClip, jumpClip;<span class="hljs-comment">//获得声音clip</span>    <span class="hljs-keyword">public</span> ParticleSystem dirtParticle, expParticle; <span class="hljs-comment">//特效</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> gravitymodifier; <span class="hljs-comment">//缓慢落下，设置重量变量</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> jumpForce;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> isGround;<span class="hljs-comment">// 默认为false</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isGameOver;<span class="hljs-comment">//判断游戏结束</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        rb = GetComponent<Rigidbody>();anim = GetComponent<Animator>();audioSource = GetComponent<AudioSource>();        Physics.gravity *= gravitymodifier;<span class="hljs-comment">//增加下落重力</span>    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space) && isGround)        {            rb.AddForce(Vector3.up * jumpForce , ForceMode.Impulse);            isGround = <span class="hljs-literal">false</span>;            anim.SetTrigger(<span class="hljs-string">"Jump_trig"</span>);<span class="hljs-comment">//设置跳跃动画触发器</span>            dirtParticle.Stop();<span class="hljs-comment">//跳跃时候终止粒子特效播放</span>            audioSource.PlayOneShot(jumpClip, <span class="hljs-number">1f</span>);        }    }    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)<span class="hljs-comment">//跳跃检测</span></span>    {        <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">"Ground"</span>))        {            isGround = <span class="hljs-literal">true</span>;            dirtParticle.Play();<span class="hljs-comment">//当落地时，粒子特效播放</span>        }        <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">"Obstacle"</span>)) /        {            isGameOver = <span class="hljs-literal">true</span>;<span class="hljs-comment">//当碰撞物体时，停止物体生成，停止背景地板后退</span>            isGround = <span class="hljs-literal">false</span>;<span class="hljs-comment">//停止跳跃功能</span>            audioSource.PlayOneShot(crashClip,<span class="hljs-number">1f</span>);<span class="hljs-comment">//播放死亡音效</span>            Debug.Log(<span class="hljs-string">"Game Over"</span>);<span class="hljs-comment">//播放死亡动画</span>            anim.SetBool(<span class="hljs-string">"Death_b"</span>,<span class="hljs-literal">true</span>);            anim.SetInteger(<span class="hljs-string">"DeathType_int"</span>,<span class="hljs-number">2</span>);             <span class="hljs-comment">//播放死亡特效，奔跑特效停止</span>            expParticle.Play();            dirtParticle.Stop();        }    }}</code></pre></div><h3 id="Rigibody-AddForce"><a href="#Rigibody-AddForce" class="headerlink" title="Rigibody.AddForce"></a>Rigibody.AddForce</h3><p>添加一个力量到钢体</p><ul><li>ForceMode.Force 默认方式，以钢体的质量计算以每帧间隔时间为单位计算动量。</li><li>ForceMode.Impulse 此种方式采用瞬间力作用方式</li></ul><h3 id="ParticleSystem-Play-ParticleSystem-Stop"><a href="#ParticleSystem-Play-ParticleSystem-Stop" class="headerlink" title="ParticleSystem.Play / ParticleSystem.Stop"></a>ParticleSystem.Play <a href="http://particlesystem.Play/" target="_blank" rel="noopener">/</a> ParticleSystem.Stop</h3><p>启动/停止 粒子特效</p><h3 id="AudioSource-PlayOneShot"><a href="#AudioSource-PlayOneShot" class="headerlink" title="AudioSource.PlayOneShot"></a>AudioSource.PlayOneShot</h3><p>播放AudioClip</p><div class="hljs"><pre><code class="hljs csharp">PlayOneShot(AudioClip clip, <span class="hljs-keyword">float</span> volumeScale = <span class="hljs-number">1.0F</span>);</code></pre></div><h3 id="Animator-Set…"><a href="#Animator-Set…" class="headerlink" title="Animator.Set…"></a>Animator.Set…</h3><h3 id="MoveLeft"><a href="#MoveLeft" class="headerlink" title="MoveLeft"></a>MoveLeft</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveLeft</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> leftBound;<span class="hljs-comment">//边界</span>    <span class="hljs-keyword">private</span> PlayerController playerController;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-comment">//playerController = GameObject.Find("Player").GetComponent<PlayerController>();</span>        playerController = FindObjectOfType<PlayerController>();<span class="hljs-comment">//使用PlayerController对象</span>    }        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (!playerController.isGameOver)        {            transform.Translate(Vector3.left * speed * Time.deltaTime);<span class="hljs-comment">//场景地板向左移动</span>        }        <span class="hljs-keyword">if</span> (transform.position.x < leftBound && gameObject.CompareTag(<span class="hljs-string">"Obstacle"</span>))        {            Destroy(gameObject);<span class="hljs-comment">//删除越界的障碍物</span>        }    }}</code></pre></div><h3 id="SpawnManager"><a href="#SpawnManager" class="headerlink" title="SpawnManager"></a>SpawnManager</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpawnManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> PlayerController playerController;    <span class="hljs-keyword">public</span> GameObject obstraclePrefab;    <span class="hljs-keyword">private</span> Vector3 spawnPos = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> startDelay, repeatRate;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        InvokeRepeating(<span class="hljs-keyword">nameof</span>(SpawnObstacle),startDelay,repeatRate);        playerController = FindObjectOfType<PlayerController>();    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SpawnObstacle</span>(<span class="hljs-params"></span>)</span> {        <span class="hljs-keyword">if</span> (!playerController.isGameOver)        {<span class="hljs-comment">//生成障碍物</span>            Instantiate(obstraclePrefab, spawnPos, Quaternion.identity);        }    }}</code></pre></div><h3 id="Quaternion-identity和transform-rotation区别"><a href="#Quaternion-identity和transform-rotation区别" class="headerlink" title="Quaternion.identity和transform.rotation区别"></a>Quaternion.identity和transform.rotation区别</h3><ul><li>Quaternion.identity就是指Quaternion(0,0,0,0),就是每旋转前的初始角度,是一个确切的值</li><li>transform.rotation是指本物体的角度,值是不确定的,比如可以这么设置transform.rotation = Quaternion.identity;</li><li>一个是值类型,一个是属性变量</li></ul><h3 id="BgRepeat"><a href="#BgRepeat" class="headerlink" title="BgRepeat"></a>BgRepeat</h3><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BgRepeat</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Vector3 startPos;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> repeatWidth;    <span class="hljs-comment">//背景循环滚动</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        startPos = transform.position;        repeatWidth = GetComponent<BoxCollider>().size.x / <span class="hljs-number">2</span>;        <span class="hljs-comment">//通过boxcollider获得一半的长度</span>    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">if</span> (transform.position.x < startPos.x - repeatWidth)        {            transform.position = startPos;        }    }}</code></pre></div><p>效果图：</p><ul><li>（转成了gif所以很卡）<br><img src="/img/2020-7-16.gif" srcset="/img/loading.gif" alt="效果图"></li></ul><hr><h1 id="Day-5-练习题"><a href="#Day-5-练习题" class="headerlink" title="Day 5 练习题"></a>Day 5 练习题</h1><p>今天的课和之前一样，属于对现有场景进行修补的，没什么难度就不写了，分享一下10道官方题。</p><!-- more --><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><img src="/img/cst1.png" srcset="/img/loading.gif" alt="测试题1"></p><h3 id="答案：B"><a href="#答案：B" class="headerlink" title="答案：B"></a>答案：B</h3><h3 id="解析：如果不设置权限的话，默认为private。"><a href="#解析：如果不设置权限的话，默认为private。" class="headerlink" title="解析：如果不设置权限的话，默认为private。"></a>解析：如果不设置权限的话，默认为private。</h3><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="/img/cst2.png" srcset="/img/loading.gif" alt="测试题2"></p><h3 id="答案：C"><a href="#答案：C" class="headerlink" title="答案：C"></a>答案：C</h3><h3 id="解析：一眼看出答案。"><a href="#解析：一眼看出答案。" class="headerlink" title="解析：一眼看出答案。"></a>解析：一眼看出答案。</h3><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p><img src="/img/cst3.png" srcset="/img/loading.gif" alt="测试题3"></p><h3 id="答案：A"><a href="#答案：A" class="headerlink" title="答案：A"></a>答案：A</h3><h3 id="解析：只有A选项让Speed-f-gt-0-25，触发动画。"><a href="#解析：只有A选项让Speed-f-gt-0-25，触发动画。" class="headerlink" title="解析：只有A选项让Speed_f>0.25，触发动画。"></a>解析：只有A选项让Speed_f>0.25，触发动画。</h3><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p><img src="/img/cst4.png" srcset="/img/loading.gif" alt="测试题4"></p><h3 id="答案：A-1"><a href="#答案：A-1" class="headerlink" title="答案：A"></a>答案：A</h3><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p><img src="/img/cst5.png" srcset="/img/loading.gif" alt="测试题5"></p><h3 id="答案：D"><a href="#答案：D" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p><img src="/img/cst6.png" srcset="/img/loading.gif" alt="测试题6"></p><h3 id="答案：C-1"><a href="#答案：C-1" class="headerlink" title="答案：C"></a>答案：C</h3><h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><p><img src="/img/cst7.png" srcset="/img/loading.gif" alt="测试题7"></p><h3 id="答案：B-1"><a href="#答案：B-1" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><p><img src="/img/cst8.png" srcset="/img/loading.gif" alt="测试题8"></p><h3 id="答案：D-1"><a href="#答案：D-1" class="headerlink" title="答案：D"></a>答案：D</h3><h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><p><img src="/img/cst9.png" srcset="/img/loading.gif" alt="测试题9"></p><h3 id="答案：B-2"><a href="#答案：B-2" class="headerlink" title="答案：B"></a>答案：B</h3><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p><img src="/img/cst10.png" srcset="/img/loading.gif" alt="测试题10"></p><h3 id="答案：A-2"><a href="#答案：A-2" class="headerlink" title="答案：A"></a>答案：A</h3><hr><h1 id="Day-6-滚动小球儿"><a href="#Day-6-滚动小球儿" class="headerlink" title="Day 6 滚动小球儿"></a>Day 6 滚动小球儿</h1><p> 一个小球游戏，十分有趣。</p><!-- more --><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>操控一个小球通过 <code>WS</code> 来控前后，通过 <code>AD</code> 来控制镜头（左右）将敌人撞到台下</li><li>可以吃增益Buff，来使碰到自身的敌人被弹开</li><li>会不断的刷新敌人和增益物品，前提为前一波的敌人死亡，往后每一批的敌人都会比之前的多一个敌人</li></ul><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="/img/unit4.gif" srcset="/img/loading.gif" alt="效果图"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>用空物体创建锚点</li><li>Input.GetButton(“String”) 获得bool值</li></ul><h2 id="SpwanManager"><a href="#SpwanManager" class="headerlink" title="SpwanManager"></a>SpwanManager</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpwanManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> GameObject enemy;    <span class="hljs-keyword">public</span> GameObject powerUp;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> spawnRange;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> enemyCount;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> waveNum = <span class="hljs-number">1</span>;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        enemyCount = FindObjectsOfType<Enemy>().Length;        <span class="hljs-keyword">if</span> (enemyCount == <span class="hljs-number">0</span>)        {            SpawnEnemy(waveNum);            waveNum++;            Instantiate(powerUp, RandomPos(), powerUp.transform.rotation);        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> Vector3 <span class="hljs-title">RandomPos</span>(<span class="hljs-params"></span>)</span> {        <span class="hljs-keyword">float</span> spawnPosX = Random.Range(-spawnRange,spawnRange);        <span class="hljs-keyword">float</span> spawnPosZ = Random.Range(-spawnRange, spawnRange);        Vector3 randomPos = <span class="hljs-keyword">new</span> Vector3(spawnPosX, <span class="hljs-number">0</span>, spawnPosZ);        <span class="hljs-keyword">return</span> randomPos;    }<span class="hljs-comment">//提供一个随机的向量，以供敌人的随机生成。</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpawnEnemy</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> wave</span>)</span> {         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i < wave; i++)        {            Instantiate(Enemy, RandomPos(), Quaternion.identity);        }    }}</code></pre></div><h3 id="FindObjectsOfType-Length"><a href="#FindObjectsOfType-Length" class="headerlink" title="FindObjectsOfType().Length"></a>FindObjectsOfType<enemy>().Length</enemy></h3><p>遍历场景中的对象，寻找Enemy类型，获得总共有多少个Enemy的数值</p><h2 id="PlayerController-1"><a href="#PlayerController-1" class="headerlink" title="PlayerController"></a>PlayerController</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEditor;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">using</span> UnityEngine.UIElements;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    <span class="hljs-keyword">private</span> GameObject focalPoint;<span class="hljs-comment">//获得中心点，以保证小球移动方向</span>    <span class="hljs-keyword">public</span> GameObject Ring;<span class="hljs-comment">//使获得buff可视化</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isPowerup;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> powerStrength;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        rb = GetComponent<Rigidbody>();        focalPoint = GameObject.Find(<span class="hljs-string">"Focal Point"</span>);    }        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">float</span> forwardInput = Input.GetAxis(<span class="hljs-string">"Vertical"</span>);        rb.AddForce(focalPoint.transform.forward * speed * forwardInput);<span class="hljs-comment">//通过判断buff的激活状态，使得可视化现实</span>        Ring.SetActive(isPowerup);<span class="hljs-comment">//通过判断buff的激活状态，来调整可视化buff与Player的绑定</span>        <span class="hljs-keyword">if</span> (isPowerup)        {            Ring.transform.position = transform.position + <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">-0.4f</span>, <span class="hljs-number">0</span>);        }    }    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter</span>(<span class="hljs-params">Collider other</span>)</span>    {<span class="hljs-comment">//获得增益</span>        <span class="hljs-keyword">if</span> (other.CompareTag(<span class="hljs-string">"PowerUp"</span>)) {            isPowerup = <span class="hljs-literal">true</span>;            <span class="hljs-comment">//Ring.SetActive(true);</span>            Destroy(other.gameObject);            StartCoroutine(PowerUpCountDown());        }    }    <span class="hljs-function">IEnumerator <span class="hljs-title">PowerUpCountDown</span>(<span class="hljs-params"></span>)</span>    {<span class="hljs-comment">//协同处理，用来给获得的增益来计时</span>        <span class="hljs-function"><span class="hljs-keyword">yield</span> return new <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;        isPowerup = <span class="hljs-literal">false</span>;        <span class="hljs-comment">//Ring.SetActive(false);</span>    }    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>    {<span class="hljs-comment">//设置buff的功能</span>         <span class="hljs-keyword">if</span> (collision.gameObject.CompareTag(<span class="hljs-string">"Enemy"</span>) && isPowerup) {            Rigidbody enemyRb = collision.gameObject.GetComponent<Rigidbody>();            Vector3 dirFromPlayer = collision.transform.position - transform.position;            enemyRb.AddForce(dirFromPlayer * powerStrength, ForceMode.Impulse);         }    }}</code></pre></div><h2 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h2><p>协同处理</p><ul><li>所有IEnumerator类型函数必须使用”StartCoroutine”这个函数触发，不能单独使用</li></ul><div class="hljs"><pre><code class="hljs csharp">StartCoroutine(DoSomeThingInDelay());</code></pre></div><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p>延迟加载，在C#中，yield不能单独使用，需要配合return 如</p><ul><li>yield return 1; 等1帧</li><li>yield return WaitForSeconds(1 );等一秒</li></ul><h2 id="Enemy"><a href="#Enemy" class="headerlink" title="Enemy"></a>Enemy</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">private</span> Rigidbody rb;    <span class="hljs-keyword">private</span> GameObject player;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        rb = GetComponent<Rigidbody>();        player = FindObjectOfType<PlayerController>().gameObject;<span class="hljs-comment">//返回的类型变量，所以后面加.gameobject</span>    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {<span class="hljs-comment">//使得enemy向player移动</span>        Vector3 playerDir = (player.transform.position - transform.position).normalized;<span class="hljs-comment">//单位化，无论他们是多少，都判定为1</span>        rb.AddForce(playerDir * speed);        <span class="hljs-keyword">if</span> (transform.position.y < <span class="hljs-number">-10</span>)        {            Destroy(gameObject);        }    }}</code></pre></div><h2 id="设置镜头移动"><a href="#设置镜头移动" class="headerlink" title="设置镜头移动"></a>设置镜头移动</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RotateCamera</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> rotationSpeed;<span class="hljs-comment">//镜头旋转</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        <span class="hljs-keyword">float</span> horizontalInput = Input.GetAxis(<span class="hljs-string">"Horizontal"</span>);        transform.Rotate(Vector3.up, horizontalInput * rotationSpeed * Time.deltaTime);    }}</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>暑期学习</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome下载文件变成html的解决方案</title>
    <link href="/2020/07/14/Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%98%E6%88%90html%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/14/Chrome%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%8F%98%E6%88%90html%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>最近发现windows那台电脑上的Chrome无论下载什么都会变成xxx.html，即便是另存为也是一样的情况。</p><a id="more"></a><p>解决方案：按住<code>Alt</code>键位再点击下载就可以了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>问题解决</tag>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity官方课程学习记录 2020.07.13-15</title>
    <link href="/2020/07/13/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.13-15/"/>
    <url>/2020/07/13/Unity%E5%AE%98%E6%96%B9%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%202020.07.13-15/</url>
    
    <content type="html"><![CDATA[<p>找了找资源，发现Unity中文社区的内容也在蓬勃发展，于是打算双线操作，一边学习C#的进阶特性，一遍开始跟着官方的课搞一搞，本篇是关于镜头绑定以及移动控制，当然，还会有一点小tips。</p><a id="more"></a><h1 id="Unit-1-镜头绑定和角色控制"><a href="#Unit-1-镜头绑定和角色控制" class="headerlink" title="Unit 1  镜头绑定和角色控制"></a>Unit 1  镜头绑定和角色控制</h1><h2 id="一点微小的知识"><a href="#一点微小的知识" class="headerlink" title="一点微小的知识"></a>一点微小的知识</h2><ul><li>按 <code>CTRL</code> 可以对transform进行微调，缺省值为0.25，可以再Grid and Snap中设置</li><li>按 <code>鼠标右键</code> 使用 <code>WASD</code> 可以进行视角移动，很方便</li><li>在 <code>Preferences</code> 中，Colors → Playmode tint，可以设置游戏在unity运行中系统页面的变化，已达到提高辨识度的效果</li></ul><h2 id="镜头绑定"><a href="#镜头绑定" class="headerlink" title="镜头绑定"></a>镜头绑定</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> GameObject player;    <span class="hljs-keyword">private</span> Vector3 offset = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">-10</span>);    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {            }        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>) <span class="hljs-comment">//每一帧都会被调用</span>        }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>(<span class="hljs-params"></span>)</span>    {        transform.position = player.transform.position + offset;    }}</code></pre></div><h2 id="Update-与-lateUpdate-的区别"><a href="#Update-与-lateUpdate-的区别" class="headerlink" title="Update() 与 lateUpdate()的区别"></a>Update() 与 lateUpdate()的区别</h2><ul><li>LateUpdate是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。<ul><li><del>人话：lateUpadate晚于Update执行</del></li><li>即使在统一帧中执行，但是Update会先执行，lateUpdate后执行</li></ul></li><li>通过这个可以解决相机绑定gameObject造成的抖动效果</li></ul><h2 id="Player移动"><a href="#Player移动" class="headerlink" title="Player移动"></a>Player移动</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span>{       <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed; <span class="hljs-comment">//private 变量在unity中不可见</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> turnSpeed;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> verticalInput;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> horizontalInput;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {            }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        verticalInput = Input.GetAxis(<span class="hljs-string">"Vertical"</span>);<span class="hljs-comment">//-1 1</span>        horizontalInput = Input.GetAxis(<span class="hljs-string">"Horizontal"</span>);        <span class="hljs-comment">//Vector3.forward 决定方向 Time.deltaTime 决定在不同设备速度一样</span>        transform.Translate(Vector3.forward * Time.deltaTime * speed * verticalInput);        transform.Rotate(Vector3.up,Time.deltaTime * turnSpeed * horizontalInput);<span class="hljs-comment">//0 1 0 </span>    }}</code></pre></div><h2 id="获得输入的方法——以“前后，左右”为例"><a href="#获得输入的方法——以“前后，左右”为例" class="headerlink" title="获得输入的方法——以“前后，左右”为例"></a>获得输入的方法——以“前后，左右”为例</h2><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul><li>通过在 <strong>Project Settings</strong> 中的 <strong>Input Manager</strong> 可以获取每个输入的值，在脚本里就可以通过Input.GetAxis(“String”)来获取。</li></ul><h3 id="Horizontal"><a href="#Horizontal" class="headerlink" title="Horizontal"></a>Horizontal</h3><ul><li>在input中决定了方向，可以通过Input.GetAxis(“Horizontal”)获取后，用transform.Rotate()来更改方向。</li><li>值为0 1 0，以float方式存储。</li></ul><h3 id="Vertical"><a href="#Vertical" class="headerlink" title="Vertical"></a>Vertical</h3><ul><li>在input中决定了前进or后退，可以通过Input.GetAxis(“Vertical”)获取后，用transform.Translate()来更改前后。</li><li>值为-1 1，以float方式存储。</li></ul><h3 id="Time-deltaTime"><a href="#Time-deltaTime" class="headerlink" title="Time.deltaTime"></a>Time.deltaTime</h3><p>留坑，第二天再写</p><h3 id="Vertical3"><a href="#Vertical3" class="headerlink" title="Vertical3"></a>Vertical3</h3><p>留坑</p><h1 id="Unit-2-基本的游戏"><a href="#Unit-2-基本的游戏" class="headerlink" title="Unit 2 基本的游戏"></a>Unit 2 基本的游戏</h1><h2 id="一点微小的知识-1"><a href="#一点微小的知识-1" class="headerlink" title="一点微小的知识"></a>一点微小的知识</h2><ul><li>通过Gizmos调整摄像机在Scene中的范围。</li><li>在Scene中，使用 <code>鼠标右键</code> + <code>滚轮</code> 可以调整用WASD控制试图的时候的移动速度。</li><li>在调整三维向量时候，为了避免搞晕自己，可以切换到各个轴视角调整，按住 <code>Ctrl</code> 后可以进行等边调整。</li><li>拖拽预制体时尽量在Hierarchy面板中，如果在Scene中很可能是悬空的。</li></ul><h2 id="游戏实现"><a href="#游戏实现" class="headerlink" title="游戏实现"></a>游戏实现</h2><p>游戏中<code>自动生成</code>朝向Player奔跑的“动物”，通过<code>左右移动</code>和<code>空格</code>发射食物，使其消失。</p><h2 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerControllor</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">40f</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> horizontalInput;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> xRange;    <span class="hljs-keyword">public</span> GameObject pizzaPrefeb;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        horizontalInput = Input.GetAxisRaw(<span class="hljs-string">"Horizontal"</span>);        transform.Translate(Vector3.right * horizontalInput * Time.deltaTime * speed);<span class="hljs-comment">//设定边界 原理：通过给判断人物transform中position的x大于边界，如果成立就把边界的值赋给其，已达到边界限制的作用。</span>        <span class="hljs-keyword">if</span> (transform.position.x > xRange)        {            transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        }        <span class="hljs-keyword">if</span> (transform.position.x < -xRange)         {            transform.position = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);        }        <span class="hljs-keyword">if</span> (Input.GetKeyDown(KeyCode.Space))         {            Instantiate(pizzaPrefeb, transform.position, pizzaPrefeb.transform.rotation);        }    }}</code></pre></div><h3 id="GetAxisRaw"><a href="#GetAxisRaw" class="headerlink" title="GetAxisRaw"></a>GetAxisRaw</h3><ul><li>与GetAxis不同的是，GetAxisRaw是从键盘获取 0，-1，0三个数，而GetAxis是获取-1，1之间的一个数，类似开车或者刹车。</li></ul><h3 id="Input-GetKeyDown"><a href="#Input-GetKeyDown" class="headerlink" title="Input.GetKeyDown"></a>Input.GetKeyDown</h3><ul><li>当用户按下指定名称的按键时的那一帧返回true</li><li>要在Update方法中调用这个方法，此后每一帧重置状态时，它将不会返回true除非用户释放这个按钮然后重新按下它</li></ul><h2 id="MoveForward"><a href="#MoveForward" class="headerlink" title="MoveForward"></a>MoveForward</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MoveForward</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> speed = <span class="hljs-number">40f</span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"></span>)</span>    {        transform.Translate(Vector3.forward * speed * Time.deltaTime); <span class="hljs-comment">//forward .z</span>        <span class="hljs-comment">//设置上下的边界</span>        <span class="hljs-keyword">if</span> (transform.position.z < <span class="hljs-number">-107f</span> )        {            Destroy(gameObject);        }    }    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter</span>(<span class="hljs-params">Collision collision</span>)</span>    {        Destroy(collision.gameObject);        Destroy(gameObject);    }}</code></pre></div><h2 id="OnCollisionEnter"><a href="#OnCollisionEnter" class="headerlink" title="OnCollisionEnter"></a>OnCollisionEnter</h2><ul><li>OncollisionEnter方法要求碰撞的发起方必须有钢体，只要碰撞双方一个有钢体，则二者都会触发OncollisionEnter方法。所以钢体是判断是否碰撞的标志。</li><li>collision.gameObject为被碰撞对象。</li></ul><h3 id="有钢体的情况"><a href="#有钢体的情况" class="headerlink" title="有钢体的情况"></a>有钢体的情况</h3><p>A对象与B对象相撞后，无论是谁先撞上的谁，都可以触发OncollisionEnter方法。</p><h3 id="没有钢体的情况"><a href="#没有钢体的情况" class="headerlink" title="没有钢体的情况"></a>没有钢体的情况</h3><p>A有钢体，B没有，A去撞B，则AB都会触发OncollisionEnter方法。</p><p>A有钢体，B没有，B来撞A，则AB都不会触发OncollisionEnter方法。</p><h3 id="Destroy"><a href="#Destroy" class="headerlink" title="Destroy"></a>Destroy</h3><ul><li>Destroy(gameObject)，用来摧毁一个游戏对象。</li></ul><h2 id="SpawnManager"><a href="#SpawnManager" class="headerlink" title="SpawnManager"></a>SpawnManager</h2><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<span class="hljs-keyword">using</span> System.Collections.Generic;<span class="hljs-keyword">using</span> System.Security.Cryptography;<span class="hljs-keyword">using</span> UnityEngine;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SpawnManager</span> : <span class="hljs-title">MonoBehaviour</span>{    <span class="hljs-keyword">public</span> GameObject[] animPrefab;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> index;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> xRange;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>(<span class="hljs-params"></span>)</span>    {        InvokeRepeating(<span class="hljs-keyword">nameof</span>(SpawnAnimal),<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);    }    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SpawnAnimal</span>(<span class="hljs-params"></span>)</span>     {        index = Random.Range(<span class="hljs-number">0</span>, animPrefab.Length);        <span class="hljs-keyword">float</span> xPosition = Random.Range(xRange, -xRange);        Instantiate(animPrefab[index], <span class="hljs-keyword">new</span> Vector3(xPosition, <span class="hljs-number">0f</span>, <span class="hljs-number">30f</span>), animPrefab[index].transform.rotation);    }}</code></pre></div><h3 id="Invoke"><a href="#Invoke" class="headerlink" title="Invoke"></a>Invoke</h3><div class="hljs"><pre><code class="hljs csharp">Invoke(methodName: <span class="hljs-keyword">string</span>, time: <span class="hljs-keyword">float</span>): <span class="hljs-keyword">void</span>;methodName:方法名time:多少秒后执行</code></pre></div><h3 id="InvokeRepeating"><a href="#InvokeRepeating" class="headerlink" title="InvokeRepeating"></a>InvokeRepeating</h3><div class="hljs"><pre><code class="hljs csharp">InvokeRepeating(methodName: <span class="hljs-keyword">string</span>, time: <span class="hljs-keyword">float</span>, repeatRate: <span class="hljs-keyword">float</span>): <span class="hljs-keyword">void</span>;methodName:方法名time:多少秒后执行repeatRate：重复执行间隔</code></pre></div><h3 id="Instantiate"><a href="#Instantiate" class="headerlink" title="Instantiate"></a>Instantiate</h3><ul><li>Instantiate(gameObject)，创建游戏对象。</li></ul><h1 id="Unit-3-一些微小的思考"><a href="#Unit-3-一些微小的思考" class="headerlink" title="Unit 3 一些微小的思考"></a>Unit 3 一些微小的思考</h1><h2 id="游戏实现-1"><a href="#游戏实现-1" class="headerlink" title="游戏实现"></a>游戏实现</h2><ul><li>人物通过空格召唤一匹马，用马来接球</li><li>如果接到球，马会消失，没接到，游戏结束</li></ul><p>太简单了就没写如何实现，写了一些思考。</p><h2 id="Prefab-Variant-与-Original-Prefab"><a href="#Prefab-Variant-与-Original-Prefab" class="headerlink" title="Prefab Variant 与 Original Prefab"></a>Prefab Variant 与 Original Prefab</h2><p>prefab是通过一个original的prefab，可以通过很多便利，比如我们创建一个没有任何属性的“人”的original prefab，这里就可以创建很多变体</p><ul><li>人的国籍</li><li>人的语言，声音等等</li></ul><p>变体的prefab会继承original的全部属性，可以通过复写改掉prefab的属性，变体可以基于任何的prefab，很像代码中的继承。</p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>因为普通的Random的随机数是通过时间生成的，短时间内多次调用会造成生成的随机数一直，如果我们需要改变的话可以通过</p><ul><li><p>每生成完随机数后让线程睡眠1ms</p><ul><li>thread.sleep(1);</li></ul></li><li><p>RNGCryptoServiceProvider(); 产生相对真的随机数</p><ul><li>使用前提：</li></ul><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Security.Cryptography;<span class="hljs-keyword">using</span> System;</code></pre></div><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">byte</span>[] randomBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">4</span>];RNGCryptoServiceProvider rngCrypto = <span class="hljs-keyword">new</span> RNGCryptoServiceProvider();rangCrypo.GetBytes(randomBytes);<span class="hljs-keyword">int</span> rngNum = BitConerter.ToInt32(randomBytes,<span class="hljs-number">0</span>)<span class="hljs-comment">//计算量很大，如果想要0-100范围的为rngNum = rngNum % 100</span></code></pre></div></li></ul><h2 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h2><p>通过设置Tag来达到在脚本中识别对象的问题，如果调用的话可以使用:</p><ul><li>gameObject.CompareTag(“String”)</li></ul><h3 id="CompareTag比gameObject-tag的优势"><a href="#CompareTag比gameObject-tag的优势" class="headerlink" title="CompareTag比gameObject.tag的优势"></a>CompareTag比gameObject.tag的优势</h3><p>由于gameObject.tag中的tag是属性，要先花时间调用一次getter来获得字符串，而CompareTag只需要调用一次内部方法，节省性能总是好的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>暑期学习</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity笔记汇总 2020.07.11-13</title>
    <link href="/2020/07/11/%E6%9A%91%E6%9C%9FU3D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9520.07.11-13/"/>
    <url>/2020/07/11/%E6%9A%91%E6%9C%9FU3D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9520.07.11-13/</url>
    
    <content type="html"><![CDATA[<p>拿暑期的时间系统的学一下U3D和C#，之前都是用什么学什么，知识点都散。之前的swift复习就鸽了，因为整理到后面发现完全没必要写= =#，最后考的也挺好。</p><a id="more"></a><p>学习资料是看的千锋初级，讲了一段u3d基础功能后就开始C#的进阶课程了。</p><blockquote><ul><li>链接: <a href="https://pan.baidu.com/s/1lZn1hqRCFF7rVGib0G2pgg" target="_blank" rel="noopener">https://pan.baidu.com/s/1lZn1hqRCFF7rVGib0G2pgg</a> </li><li>提取码: kq6z</li></ul></blockquote><h1 id="2020-07-11"><a href="#2020-07-11" class="headerlink" title="2020.07.11"></a>2020.07.11</h1><p>以下为本日所学：</p><h2 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h2><p><code>ducplicate</code>  复制 和 <code>copy</code>  拷贝 不一样</p><p><code>Edit</code> </p><p><code>Preference</code> 偏好设置</p><p><code>Assests</code> 资源</p><p><code>show in explorer</code> 在文件管理器这打开</p><p><code>import Package</code> 导入资源包</p><p><code>GameObject</code> 游戏对象</p><p><code>Component</code> 组件</p><p><code>Window</code>  unity 面板窗口</p><p><code>Help</code> </p><h2 id="面板"><a href="#面板" class="headerlink" title="面板"></a>面板</h2><p><code>Layout</code> 布局方式 </p><p><code>Revert Factory</code>  恢复出厂设置</p><p><code>Project</code> 项目面板——管理一个项目中用到的所有资源文件</p><p><code>Scene</code> 场景面板——用来编辑场景，列出场景中所有的对象</p><p><code>Game</code> 游戏面板——玩家看到的面板，由场景中的摄像机拍摄到的 </p><p><code>Hierarchy</code> 层级面板——管理所有中的游戏对象，将所有的游戏对象以层级的形式列举出来</p><p><code>Inspector</code> 检视面板——显示一个游戏对象身上的组件；显示组件中的属性</p><h2 id="空间坐标系"><a href="#空间坐标系" class="headerlink" title="空间坐标系"></a>空间坐标系</h2><p><code>坐标系</code>  unity：左手坐标系，数学：右手坐标系</p><h2 id="场景中的操作"><a href="#场景中的操作" class="headerlink" title="场景中的操作"></a>场景中的操作</h2><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p><code>旋转</code>  alt+左键 or 右键</p><p><code>右上角的锁</code>  锁定旋转</p><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p><code>缩放</code>  鼠标滚轮</p><h2 id="快速的在场景中找到指定的游戏对象"><a href="#快速的在场景中找到指定的游戏对象" class="headerlink" title="快速的在场景中找到指定的游戏对象"></a>快速的在场景中找到指定的游戏对象</h2><ul><li>在Hierarchy中找到对象，双击</li><li>在Hierarchy中单机选中，在场景中按F</li></ul><h2 id="拖动场景"><a href="#拖动场景" class="headerlink" title="拖动场景"></a>拖动场景</h2><p><code>拖动</code> 按住鼠标中键；Q</p><h2 id="左上角的工具——快捷键依次为QWERT"><a href="#左上角的工具——快捷键依次为QWERT" class="headerlink" title="左上角的工具——快捷键依次为QWERT"></a>左上角的工具——快捷键依次为QWERT</h2><p><code>手</code> 移动</p><p><code>Move tool</code> 移动物体 影响Transform.Position</p><p><code>Rotate Tool</code> 旋转 影响Transform.Rotation</p><p><code>Scale Tool</code> 缩放 影响Transform.Scale</p><p><code>Rect Tool</code> 缩放</p><h2 id="切换中心点"><a href="#切换中心点" class="headerlink" title="切换中心点"></a>切换中心点</h2><ul><li>Pivot 选中的游戏对象中心点</li><li>Center 所有选中的对象的计算出来的中心点</li><li>快捷键位：Z</li></ul><h2 id="切换坐标系"><a href="#切换坐标系" class="headerlink" title="切换坐标系"></a>切换坐标系</h2><ul><li>Global 采用世界坐标——东南西北</li><li>Local 采用自身坐标——前后左右</li><li>快捷键：X</li></ul><h2 id="GameObject"><a href="#GameObject" class="headerlink" title="GameObject"></a>GameObject</h2><h2 id="父子物体关系"><a href="#父子物体关系" class="headerlink" title="父子物体关系"></a>父子物体关系</h2><ul><li>一个游戏对象，只能有一个父物体</li><li>一个游戏对象，可以有无数个子物体</li><li>子物体的操作不会对父物体产生影响，反之则会</li><li>子物体的位置、旋转、缩放都是相对于父物体的</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>具有一定功能的集合</li><li>如果希望游戏对象具有什么功能，只需要给这个游戏对象添加相应的组件即可</li></ul><h3 id="Mesh-Filter"><a href="#Mesh-Filter" class="headerlink" title="Mesh Filter"></a>Mesh Filter</h3><ul><li>网格过滤器，决定了一个对象的形状</li></ul><h3 id="Mesh-Renderer"><a href="#Mesh-Renderer" class="headerlink" title="Mesh Renderer"></a>Mesh Renderer</h3><ul><li>决定了一个游戏对象的外观展示</li></ul><h2 id="材质-Material"><a href="#材质-Material" class="headerlink" title="材质 Material"></a>材质 Material</h2><ul><li>决定一个对象的外观</li></ul><hr><h1 id="2020-07-12"><a href="#2020-07-12" class="headerlink" title="2020.07.12"></a>2020.07.12</h1><p>（题外话，早点起床会觉得一天特别充实！）</p><p>接上篇，今日学习为：</p><!-- more --><h2 id="预制体"><a href="#预制体" class="headerlink" title="预制体"></a>预制体</h2><ul><li>将某个游戏对象以文件的形式存储起来</li><li>作用：用来批量管理游戏对象；修改预制体的缩放，会对所有的游戏对象都产生影响；给预制体加上组件，所有的对象都会有添加组件</li></ul><p><code>Select</code> 快速找到这个对象对应的预制体</p><p><strong>Overrides</strong></p><p><code>Revert</code> 将游戏对象的组件及属性还原为预制体中的定义</p><p><code>Apply</code> 将对象的属性应用到预制体</p><h2 id="资源包"><a href="#资源包" class="headerlink" title="资源包"></a>资源包</h2><ul><li>可以把项目中的资源打包导出</li><li>如何打包Project下 → Export packages</li><li>如何导入Project下 → Import packages；拖进project；直接双击资源</li><li>标准资源包：Standard Assest 路径Unity/Editor/Standard</li></ul><h2 id="地形-Terrain"><a href="#地形-Terrain" class="headerlink" title="地形 Terrain"></a>地形 Terrain</h2><p>组件</p><ul><li>Raise/Lower Terrain——升高or下降的地形<ul><li>Brushes 笔刷</li><li><code>Opacity</code> 笔刷的硬度，决定一次抬高的高度</li><li>按住 <code>Shift</code> 可以降低，但最低是和terrain平行</li></ul></li><li>Paint Height——设置一个高度，然后将高于这个高度的部分刷低，将低于的这个高度的部分刷高<ul><li>Hold on <code>shift</code> 可以从已有高度选取高度</li><li>Flatten 将设定的高度应用给整个地形</li></ul></li><li>Smooth Height——平滑地形，使棱角分明的地方变得圆润平滑</li><li>Paint Texture——绘制地面纹理<ul><li>第一个添加的纹理会作用给全部的地形</li></ul></li><li>Place Trees<ul><li>Density 密度</li></ul></li><li>Paint Detail</li><li>Settings</li></ul><h2 id="钢体-Rigidbody"><a href="#钢体-Rigidbody" class="headerlink" title="钢体 Rigidbody"></a>钢体 Rigidbody</h2><p>模拟现实中的物理效果</p><ul><li>Mass 质量</li><li>Drag  拉力——运动方向的阻力</li><li>Angular Drag 旋转的拉力</li><li>Use Gravity 使用重力</li><li>Is Kinematic 开启运动学</li><li>Interpolate 插值</li><li>Collision Detection 碰撞检测</li><li>Constraints 约束<ul><li>Freeze Position</li><li>Freeze Potation</li></ul></li></ul><h2 id="碰撞体组件-Collider"><a href="#碰撞体组件-Collider" class="headerlink" title="碰撞体组件 Collider"></a>碰撞体组件 Collider</h2><p>两个物体发生碰撞，实际上产生的是两个碰撞体</p><h2 id="物理材质-Physics-Material"><a href="#物理材质-Physics-Material" class="headerlink" title="物理材质 Physics Material"></a>物理材质 Physics Material</h2><p>如果没有设置物理材质，摩擦力为无限大，弹力为0</p><ul><li>Dynamic Fricction 动态摩擦力</li><li>Static Friction 静态摩擦力 没有相对位移时候的摩擦力</li><li>Bounciness 弹力</li><li>Friction Combine 阻隔摩擦力</li><li>Bounce Combine 弹力摩擦力</li></ul><hr><h1 id="2020-07-13"><a href="#2020-07-13" class="headerlink" title="2020.07.13"></a>2020.07.13</h1><p>基础的unity功能看完了，明天开始要开始C#的进阶了。</p><!-- more --><h2 id="fbx-模型文件"><a href="#fbx-模型文件" class="headerlink" title=".fbx 模型文件"></a>.fbx 模型文件</h2><ul><li>模型文件最好Z轴指向的是前方</li></ul><h2 id="人物控制"><a href="#人物控制" class="headerlink" title="人物控制"></a>人物控制</h2><p>获取<em>水平轴</em>的偏移量，<em>垂直轴</em>的偏移量</p><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-keyword">float</span> horizontal = Input.GetAxis(<span class="hljs-string">"Horiziontal"</span>);<span class="hljs-keyword">float</span> vertical = Input.GetAxis(<span class="hljs-string">"Vertical"</span>);</code></pre></div><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-comment">// 判断是否有位移</span>        <span class="hljs-keyword">if</span> (direction != Vector3.zero)        {            <span class="hljs-comment">//将角色旋转至指定的方向</span>            transform.rotation = Quaternion.LookRotation(direction);            <span class="hljs-comment">//角色移动</span>            transform.Translate(Vector3.forward * <span class="hljs-number">1</span> * Time.deltaTime);        }</code></pre></div><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p>具有大小和方向的，如果只有大小没有方向为标量</p><div class="hljs"><pre><code class="hljs csharp"><span class="hljs-comment">//算出方向向量</span>Vector3 direction = <span class="hljs-keyword">new</span> Vector3(horizontal,<span class="hljs-number">0</span>,vertical);</code></pre></div><h1 id="back-to-C"><a href="#back-to-C" class="headerlink" title="back to C"></a>back to C</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul><li>十进制 逢十进一 数字由0~9来表示</li><li>二进制 逢二进一 数字由0~1来表示</li><li>八进制 逢八进一 数字由0~7来表示</li><li>十六进制 逢十六进一 数字由0<del>9 A</del>F 来表示</li></ul><ul><li>对于二进制来说，每进一位相当于乘2，对于十进制来说，每进一位相对于乘10，以此类推</li></ul><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><ul><li>十进制与其他进制转换<ul><li>转其他进制 <code>辗转相除法</code> 用这个数字除想<em>要转换的进制</em>，再用商除进制，一直到商为0，结束，将每一步的余数倒着连起来</li><li>转十进制 用某位的数字，乘进制的位数-1次方</li></ul></li><li>二进制与八进制、十六进制的转换<ul><li>二进制与八进制 一个八进制位 == 三个二进制位</li><li>二进制与十六进制 一个十六进制位 == 四个二进制位</li></ul></li></ul><h2 id="常用单位转换"><a href="#常用单位转换" class="headerlink" title="常用单位转换"></a>常用单位转换</h2><ul><li>把每一个二进制位称作一个比特位 ⇒ bit</li><li>8bit ⇒ 1byte</li><li>1024byte ⇒ 1kb</li><li>1024kb ⇒ 1Mb</li><li>1024Mb ⇒ 1Gb</li><li>1024Gb ⇒ 1Tb</li><li>1024Tb ⇒ 1Pb</li></ul><h2 id="表示负数"><a href="#表示负数" class="headerlink" title="表示负数"></a>表示负数</h2><ul><li>把一个二进制最左边一位叫做最高位</li><li>如果需要表示负数，最高位为符号位，表示一个数字的大小，表示一个数字的正负性</li><li>如果最高位为1是负数，最高位为0为正数</li></ul><h2 id="原码，反码，补码"><a href="#原码，反码，补码" class="headerlink" title="原码，反码，补码"></a>原码，反码，补码</h2><ul><li>意义：所有数据在计算中存储和运算都是以补码的形式进行的</li><li>如果计算结果出现了溢出，则溢出的位全部舍去</li><li>由一个负数的补码求原码：对这个数字再求一次补码</li></ul><p>————————————————————————————</p><ul><li>原码：直接由其他进制计算过来的结果</li><li>反码：对原码符号位不变，其他位按位取反</li><li>补码：反码加1</li></ul><ul><li>以上规则仅限负数</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我以前居然写了这么多东西么= =# </p><p>2020.12.26</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>暑期学习</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swift基础语法</title>
    <link href="/2020/07/07/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/07/07/Swift%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="期末考试周"><a href="#期末考试周" class="headerlink" title="期末考试周"></a>期末考试周</h2><p>整理一下考试用到的Swift的基本语法，权当复习，一共会有四篇。本篇包含了注释，变量，常量，声明方式，数据类型，元祖，数组，字典。</p><a id="more"></a><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Swift有两种注释方式:<br><code>单行注释</code></p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-comment">// 我是单行注释</span></code></pre></div><p><code>多行注释</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-comment">/* 我是多行注释我是第二行*/</span></code></pre></div><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><p>常量关键字为 <code>let</code> 常量不支持再进行赋值操作</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> <span class="hljs-type">PI</span> = <span class="hljs-number">3.1415926</span></code></pre></div><p>此时如果再给PI赋值，就会报错，这时候我们可以使用变量 <code>var</code></p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> wage = <span class="hljs-number">500</span>wage = <span class="hljs-number">700</span> <span class="hljs-comment">//将700再次赋值给wage，此时不会报错</span></code></pre></div><p>##声明方式：</p><p><code>隐式声明变量</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> name = value</code></pre></div><p><code>显示声明变量</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> name:type = value</code></pre></div><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><p>如果没有一个有效的命名，回过头来就很可能忘了这个变量或者常量是做什么使用的，所以这时候我们需要<strong>命名规范</strong></p><p><code>小驼峰命名</code> 除了首个单词,其他单词首字母大写,拼接起来</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> currentBuildingHeight = <span class="hljs-number">26</span></code></pre></div><p><code>大驼峰命名</code>或者叫<code>帕斯卡命名</code> 所有的单词都首字母大写</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> <span class="hljs-type">CurrentBuildingHeight</span> = <span class="hljs-number">26</span></code></pre></div><p><code>下划线命名法</code> 用下划线🔗 所有单词</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> current_building_height = <span class="hljs-number">26</span></code></pre></div><p><code>常量的命名方式</code><br>所有字母全部大些，并皆适用下划线连接单词，用尽可能的名称描述出常量的意义</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> <span class="hljs-type">BUILDING_LEVEL_HEIGHT</span> = <span class="hljs-number">3</span> <span class="hljs-comment">//使用常量 描述层高</span></code></pre></div><h2 id="打印方式"><a href="#打印方式" class="headerlink" title="打印方式"></a>打印方式</h2><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">let</span> <span class="hljs-type">BUILDING_LEVEL_HEIGHT</span> = <span class="hljs-number">3</span><span class="hljs-built_in">print</span>(<span class="hljs-type">BUILDING_LEVEL_HEIGHT</span>)<span class="hljs-built_in">debugPrint</span>(<span class="hljs-type">BUILDING_LEVEL_HEIGHT</span>)<span class="hljs-built_in">dump</span>(<span class="hljs-type">BUILDING_LEVEL_HEIGHT</span>)   <span class="hljs-comment">//dump在打印class的时候，会输出class中的全部属性</span></code></pre></div><h2 id="基本的数据类型"><a href="#基本的数据类型" class="headerlink" title="基本的数据类型"></a>基本的数据类型</h2><p><strong>1、布尔类型 Bool</strong></p><p><code>Bool类型</code>用来表示true和false，不过和c语言中<strong>不一样</strong>的是，swift对于bool的定义只有true和false，不能通过1和0来代替</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> bol:<span class="hljs-type">Bool</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//使用显式声明变量 bol，bol为true</span><span class="hljs-keyword">if</span>(bol){<span class="hljs-built_in">print</span>(<span class="hljs-string">"1"</span>) <span class="hljs-comment">//因为bol为true，所以执行语句print，输出1</span>}</code></pre></div><p><strong>2、整形 Int</strong></p><p><code>Int类型</code>用来表示整数</p><p>在32位系统中,Int类型代表了Int32,表示在内存中他存储的是32位长<br>在64位系统中,Int类型代表了Int64,表示在内存中他存储的是64位长</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> <span class="hljs-type">Interg</span>:<span class="hljs-type">Int</span> = <span class="hljs-type">Int</span>.<span class="hljs-built_in">max</span><span class="hljs-keyword">var</span> <span class="hljs-type">Max</span>:<span class="hljs-type">Int64</span> = <span class="hljs-type">Int64</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">//显示64位内存中储存的Int64长度 9223372036854775807</span></code></pre></div><p>以Int8为例，Int8的最大值应该是128，但因为会有来表示的符号的最高位，所以最大值为127</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> num:<span class="hljs-type">Int8</span> = <span class="hljs-type">Int8</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">//127</span></code></pre></div><p>无符号Int8,没有位数限制，故为255</p><div class="hljs"><pre><code class="hljs Swift"><span class="hljs-keyword">var</span> num:<span class="hljs-type">UInt8</span> = <span class="hljs-type">UInt8</span>.<span class="hljs-built_in">max</span> <span class="hljs-comment">//255</span></code></pre></div><p><strong>3、浮点型 Float\Double</strong></p><p><code>浮点型</code>用来存放小数，其中Float为单精度，存放32位；Double为双精度，存放64位<br>Double可以保证15位小数精度，Float保证6位小数精度，如果超出精确度会有问题</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> float:<span class="hljs-type">Float</span> = <span class="hljs-number">0.123456</span><span class="hljs-keyword">var</span> double:<span class="hljs-type">Double</span> = <span class="hljs-number">0.012345678912345</span></code></pre></div><p><strong>4、字符与字符串 String\Char</strong><br><code>String</code>用来存放一串字符，可以是字母，数字，符号等，使用<code>“”</code>双引号赋值</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> str:<span class="hljs-type">String</span> = <span class="hljs-string">"hello，world！"</span></code></pre></div><p><code>Char</code>用来存放字符，是Charactor的缩写,同样用双引号赋值</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> char:<span class="hljs-type">String</span> = <span class="hljs-string">"H"</span></code></pre></div><p><strong>部分转义</strong><br>因为在一些情况下，直接使用符号可能会造成混乱导致编译失败，或者我们要实现别的功能,我们可以使用\来进行转义</p><div class="hljs"><pre><code class="hljs swift">\t 制表\r 回车\n 换行\' 单引号\'' 双引号\\ 反斜杠\<span class="hljs-number">0</span> 空字符</code></pre></div><h2 id="元祖-Tuple"><a href="#元祖-Tuple" class="headerlink" title="元祖 Tuple"></a>元祖 Tuple</h2><p><code>元祖</code>是多个元素相关联的一个对象，Tuple（Type1,Type2,…）</p><p><code>匿名元祖</code></p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple1:(<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Bool</span>) = (<span class="hljs-string">"张三"</span>,<span class="hljs-number">23</span>,<span class="hljs-literal">true</span>)<span class="hljs-comment">//匿名元祖只能点下标来取值</span>tuple1.<span class="hljs-number">0</span> <span class="hljs-comment">//输出为张三</span></code></pre></div><p><code>非匿名元祖</code> 优先使用</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> tuple2:(name:<span class="hljs-type">String</span>,age:<span class="hljs-type">Int</span>,gender:<span class="hljs-type">Bool</span>) = (name:<span class="hljs-string">"李四"</span>,age:<span class="hljs-number">24</span>,gender:<span class="hljs-literal">true</span>)tuple2.name<span class="hljs-comment">//输出为李四</span></code></pre></div><h2 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h2><p><code>数组</code>是一个同种类型的集合<br>数组的一种声明方式</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> array:<span class="hljs-type">Array</span><<span class="hljs-type">Int</span>> = <span class="hljs-type">Array</span><<span class="hljs-type">Int</span>>()</code></pre></div><p>数组的声明方式2</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> array2:[<span class="hljs-type">Int</span>] = [<span class="hljs-type">Int</span>]()</code></pre></div><p>直接声明</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> array3 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]</code></pre></div><p>数组如何添加</p><div class="hljs"><pre><code class="hljs swift">array.append(<span class="hljs-number">0</span>)array.append(<span class="hljs-number">6</span>)array.append(<span class="hljs-number">8</span>)array.append(<span class="hljs-number">5</span>)</code></pre></div><p><strong>数组的下标(索引) 是从0开始计算的</strong></p><p>数组的访问</p><div class="hljs"><pre><code class="hljs swift">array[<span class="hljs-number">0</span>]array[<span class="hljs-number">1</span>]array[<span class="hljs-number">3</span>]</code></pre></div><p>数组的插入</p><div class="hljs"><pre><code class="hljs swift">array.insert(<span class="hljs-number">3</span>, at: <span class="hljs-number">0</span>) <span class="hljs-comment">//把数字3插入下标0</span></code></pre></div><p>数组删除</p><div class="hljs"><pre><code class="hljs swift">array.remove(at: <span class="hljs-number">3</span>)</code></pre></div><p>数组的排序</p><div class="hljs"><pre><code class="hljs swift">array.<span class="hljs-built_in">sort</span>(by:>)</code></pre></div><p><strong>多维数组</strong><br>声明方式1:</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> multiArray:[[<span class="hljs-type">Int</span>]] = [[<span class="hljs-type">Int</span>]]()</code></pre></div><p>声明方式2:</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> multiArray2 = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]]</code></pre></div><h2 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 Dictionary"></a>字典 Dictionary</h2><p><code>Dictionary</code>是以键值对的方式存储数据</p><div class="hljs"><pre><code class="hljs swift"><span class="hljs-keyword">var</span> dic:<span class="hljs-type">Dictionary</span><<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>> = <span class="hljs-type">Dictionary</span><<span class="hljs-type">String</span>,<span class="hljs-type">Int</span>>()<span class="hljs-comment">//新华字典 用名字找页号的例子</span>dic[<span class="hljs-string">"安"</span>] = <span class="hljs-number">7</span>dic[<span class="hljs-string">"周"</span>] = <span class="hljs-number">361</span></code></pre></div><p>字典如何移除</p><div class="hljs"><pre><code class="hljs swift">dic.remove(at: dic.index(forKey: <span class="hljs-string">"周"</span>)!)</code></pre></div><p>显示字典的键、值</p><div class="hljs"><pre><code class="hljs swift">dic.valuesdic.keys</code></pre></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>联想小新13Pro 更换开机页面</title>
    <link href="/2020/06/24/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0Pro13%20%E6%9B%B4%E6%8D%A2%E5%BC%80%E6%9C%BA%E9%A1%B5%E9%9D%A2/"/>
    <url>/2020/06/24/%E8%81%94%E6%83%B3%E5%B0%8F%E6%96%B0Pro13%20%E6%9B%B4%E6%8D%A2%E5%BC%80%E6%9C%BA%E9%A1%B5%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要修改？"><a href="#为什么要修改？" class="headerlink" title="为什么要修改？"></a>为什么要修改？</h2><p>联想小新的开机页面太丑了，找遍论坛也没有个替换方法。研究了一下，发现修改开机logo是要更改BIOS的，找遍网络发现一个开源工具<code>HackBGRT</code>，可以很快的实现。（请先看注意事项，再操作）</p><a id="more"></a><p><del>（原本的开机页面像天猫logo不说，还是七彩的）</del></p><h2 id="步骤一：下载开源软件HackBGRT"><a href="#步骤一：下载开源软件HackBGRT" class="headerlink" title="步骤一：下载开源软件HackBGRT"></a>步骤一：下载开源软件HackBGRT</h2><p>在发布页面下好软件后，解压。</p><p><img src="/img/thkj02.png" srcset="/img/loading.gif" alt="下载解压"></p><blockquote><ul><li>GitHub地址 ：<a href="https://github.com/Metabolix/HackBGRT/releases" target="_blank" rel="noopener">https://github.com/Metabolix/HackBGRT/releases</a></li></ul></blockquote><h2 id="步骤二：安装软件"><a href="#步骤二：安装软件" class="headerlink" title="步骤二：安装软件"></a>步骤二：安装软件</h2><p>需要使用管理员权限来打开Setup.exe，在弹出的cmd窗口下，输入<strong>I (大写)</strong>，来进行安装，安装过后会弹出一个文本文档，我们选择关闭。</p><p><img src="/img/thkj03.png" srcset="/img/loading.gif" alt="安装软件"></p><h2 id="步骤三：修改图片"><a href="#步骤三：修改图片" class="headerlink" title="步骤三：修改图片"></a>步骤三：修改图片</h2><p>正常来说，上一步操作过后会弹出一个画图的窗口，这时候我们就可以把我们想要的开机图片提前修改好，然后<strong>拷贝</strong>到里面，覆盖掉原始图片，保存即可。</p><p><img src="/img/thkj04.png" srcset="/img/loading.gif" alt="修改图片"></p><h2 id="步骤四：完成-amp-注意事项"><a href="#步骤四：完成-amp-注意事项" class="headerlink" title="步骤四：完成&注意事项"></a>步骤四：完成&注意事项</h2><p>重启即可，我们可以看到现在的开机页面已经变成了我们修改的图片。<del>（果然联想电脑还是应该用联想的logo）</del></p><p><img src="/img/thkj05.png" srcset="/img/loading.gif" alt="完成"></p><hr><h2 id="注意事项（请优先观看）"><a href="#注意事项（请优先观看）" class="headerlink" title="注意事项（请优先观看）"></a>注意事项（请优先观看）</h2><p>1.系统需要为UEFI引导，请提前查看Boot Mode启动方式<br>2.需要关闭Secure Boot (既把Secure Boot设置为Disabled)<br>3.请直接替换画图里的图片，并非软件目录中的splash.bmp<br>4.如果需要换回原来的的开机画面，只需要再次Setup.exe 输入 R 即可恢复<br>5.如果不走运无法开机，请使用系统恢复修复启动问题<br>6.系统更新后可能会失效，需要重新设置(2020.08.05补充)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从网易云导入音乐到Apple Music</title>
    <link href="/2019/07/22/%E4%BB%8E%E7%BD%91%E6%98%93%E4%BA%91%E5%AF%BC%E5%85%A5%E9%9F%B3%E4%B9%90%E5%88%B0AppleMusic/"/>
    <url>/2019/07/22/%E4%BB%8E%E7%BD%91%E6%98%93%E4%BA%91%E5%AF%BC%E5%85%A5%E9%9F%B3%E4%B9%90%E5%88%B0AppleMusic/</url>
    
    <content type="html"><![CDATA[<p>随着<code>网易云音乐</code>的版权越来越少，功能越来越臃肿，歌词被和谐，我决定换到<code>Apple Music</code>一段时间试试，但由于网易云每个歌单都有好几百首音乐，如果一首一首的导入太麻烦了，便开始研究如何将歌单完美导入。</p><a id="more"></a> <p>采用的方法是：<code>Apple Music</code>资料库里有的音乐，使用<code>TunemyMusic</code>来导入，库里没有的音乐使用<code>iCloud音乐库</code>来进行云播放。</p><p>下面是具体方法：</p><h2 id="步骤一：下载浏览器的油猴插件"><a href="#步骤一：下载浏览器的油猴插件" class="headerlink" title="步骤一：下载浏览器的油猴插件"></a>步骤一：下载浏览器的油猴插件</h2><p><img src="/img/wa11.png" srcset="/img/loading.gif" alt="header"></p><blockquote><ul><li>油猴安装教程 ：<a href="https://zhuanlan.zhihu.com/p/52182666" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/52182666</a></li></ul></blockquote><h2 id="步骤二：安装油猴脚本，并启动"><a href="#步骤二：安装油猴脚本，并启动" class="headerlink" title="步骤二：安装油猴脚本，并启动"></a>步骤二：安装油猴脚本，并启动</h2><p><img src="/img/wa12.png" srcset="/img/loading.gif" alt="header"></p><blockquote><ul><li>安装网址 ：<a href="http://t.cn/AilEhyvb" target="_blank" rel="noopener">http://t.cn/AilEhyvb</a></li></ul></blockquote><h2 id="步骤三：网易云分享歌单，导出txt格式文件"><a href="#步骤三：网易云分享歌单，导出txt格式文件" class="headerlink" title="步骤三：网易云分享歌单，导出txt格式文件"></a>步骤三：网易云分享歌单，导出txt格式文件</h2><p><img src="/img/wa13.png" srcset="/img/loading.gif" alt="header"><br>以链接的方式分享你想要导入<code>Apple Music</code>的歌单，用安装了油猴脚本的浏览器打开，选择导出。<br><img src="/img/wa14.png" srcset="/img/loading.gif" alt="header"><br>下载后打开，会获得如下所示：<br><img src="/img/wa15.png" srcset="/img/loading.gif" alt="header"></p><h2 id="步骤四：使用TunemyMusic来导入音乐到Apple-Music"><a href="#步骤四：使用TunemyMusic来导入音乐到Apple-Music" class="headerlink" title="步骤四：使用TunemyMusic来导入音乐到Apple Music"></a>步骤四：使用TunemyMusic来导入音乐到Apple Music</h2><blockquote><ul><li>进入官网 ：<a href="https://www.tunemymusic.com/zh-cn/" target="_blank" rel="noopener">https://www.tunemymusic.com/zh-cn/</a></li></ul></blockquote><p>在来源选择中选择<code>从文本</code>：<br><img src="/img/wa16.png" srcset="/img/loading.gif" alt="header"><br>如图所示，将刚才的文本内容粘贴至此：<br><img src="/img/wa17.png" srcset="/img/loading.gif" alt="header"><br>选择目的地为<code>Apple Music</code>，并登录<code>Apple ID</code>：<br><img src="/img/wa18.png" srcset="/img/loading.gif" alt="header"><br>登陆完成就可以看到已经开始向<code>Apple Music</code>添加了，剩下的等着就好。<br><img src="/img/wa19.png" srcset="/img/loading.gif" alt="header"><br>其余导入失败可以从网易云下载，使用<code>iTunes</code>播放，就会自动添加进<code>iCloud音乐库</code>了。<br><img src="/img/wa110.png" srcset="/img/loading.gif" alt="header"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
    <tags>
      
      <tag>日常</tag>
      
      <tag>小技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/07/18/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/"/>
    <url>/2019/07/18/%E4%BD%A0%E5%A5%BD%EF%BC%8C%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p>花了3个晚上终于把这个鬼东西整的差不多了。<br>不知道写点儿啥，就先这样子。</p><a id="more"></a> <hr><p><img src="/img/demo.jpg" srcset="/img/loading.gif" alt="header"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
